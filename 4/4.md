Silvan: All right, so just repeating the question about, you might be able to get Nix into your company,
but you aren't sure about the whole flakes situation, and it being labeled as experimental stuff,
and just kind of some clarification about that, what the best practice would be and if it's a 
good idea to get into Nix now, does that sound about accurate?

Q: Yeah basically when I look at documentation there is two different approaches fundamentally,
and I don't know really if I can propose, "hey we can use that for our project, but it's experimental",
it just seems a little bit crazy to do that. 

Silvan: Yeah, yeah, so personally what I would go for is to hold off flakes just for the time being.
Maybe I can, do we have anything good to look at, mhm, maybe the, let me share my browser window here,
so flakes is in the process of, there is some effort to stabilize it, we can maybe go into, here
RFC's 127, no it's not this one, this one, RFC number 136. This is an RFC that lays out kind of first
steps towards stabilizing flakes and so that's currently going on. Just recently the Nix team has been
founded, there is weekly events I think on discourse, they are publishing meeting notes, the Nix team,
Nix team creation yeah, https://discourse.nixos.org/t/nix-team-creation/22228.

So the Nix team has been created recently to kind of distribute the Nix development process a bit, so
the Nix repositories is where all of the flake magic currently is and currently marked as experimental,
and up to recently Eelco Dolstra, the inventor of, or creator of Nix was pretty much the main person to
do this development, to do the merges and pull request reviews and he kind of gave the direction of Nix.
And that's also kind of how flakes came to be, but recently because this was deemed not super stable,
or not super sustainable, the Nix team has been created to kind of have more than one person do this flow
and make sure Nix can progress and there's a good vision and stuff like that.

Also recently, this kind of all happened at the same I'd say, at NixCon, there was a lot of talk about, uh
well a lot of people met and a lot of things have been discussed, and I don't think a lot of flake discussions
have been had, it most mostly kind of an avoided topic, it's definetly the elephant in the room currently,
in the nix community, but what should we do about that. So I'm optimistic that in let's say in the next
year, either, yeah in the next year I'd say flakes can get stabilized. How it's gonna get stabilized, I'm
not sure, it might stay the way it is right now which I think it's problematic for some reasons, or 
it might change in backwards incompatible ways, and because we don't know I would not recommend adopting
flakes at the moment. Only, not like on a large scale at least. If you want to try out flakes because it is
an experimental feature that might be cool to try out but I wouldn't recommend building it into the stable
workflow of everyday developers. Just, well, of course I am a bit biased, flakes does provide a lot of benefit
that is a bit harder to get in standard nix or traditional nix, say, but there are a lot of things, there are,
flakes does provide a lot of utility but you can also get some of that in standard nix if you adopt some
conventions and stuff. So I think I'll go now into some, into showing a bit about how I think flakes, a lot
of features of flakes can be gotten regardless without flakes, so you can still use stable nix without depending
on flakes. Does that sound good or are there any questions about things I've just said?

Q: No, that be very helpful yeah.

Silvan: All right, let me share this then

```bash
cd nix-hour
mkdir flakes
cd flakes
vim flake.nix
```
One of the main things flakes gets you is the pure evaluation. So let's say we have a `flake.nix` file, we
have a simple, let's say `outputs` equal `self`, then let's also take `nixpkgs`, we just then, let's do,
let's say `foo` equals, say `import` nixpkgs, and then let's go, well let's not do anything for now, let's just
do this and see what happens.

```nix
{

  outputs = { self, nixpkgs }: {
    foo = import nixpkgs {};
  };
}
````
So let's say `myHello`, let's call it like that, `myHello = (import nixpkgs {}).hello;`, so let's say you have
a very simple flake here, you import nix packages and now we need to call `:!nix flake lock` I believe, oh actually,
it totally crashed actually, did it? No, it just was very slow. Let's do `git init` here because flakes relies on
git repositories, let's add all the files here, `gaa`, and now we should be able to `nix flake show`, all right,
so it did create a lock file automatically locking the nix packages I believe (checks the .lock file). Now, let's
try the `nix build .#myHello`, and so now we get this error (`error: attribute 'currentSystem' missing`), and 
this is going to be when you use flake you see a lot of these errors unless you, well, not a lot, it's fairly easy
to get around it but this is the pure evaluation of flakes that if you use flakes, nix enforces a pure evaluation
of your nix code. This means there is no access to `builtins.currentSystem` which we see here:

```nix
nix-repl> builtins.currentSystems
"x86_64-linux"
```
Current system is different on whatever system you evaluated on. If I were on darwin it would be a different
string here so this is why it's impure, the same expression leads to different results on different systems
and environments. Similarly there is `builtins.getEnv "USER"` which allows you to get the environment variables
in nix which is of course impure because it depends on the environment and there's a bunch of others like this.

And flakes enables pure evaluation mode by default, uh yeah, so this is impossible, there is a way to get around
this but this is discouraged of course, there is `--impure`, this then works, `nix build .#myHello --impure`.
But yeah, to fix it in flakes you have to explicitly pass the system in this case, system equals then let's say,
in here, then we can't use `builtins.currentSystem` because of course that's impure, that's also the default and so
if I pass the system here it does work, oh let's do impure and it also works:

```nix
{

  outputs = { self, nixpkgs }: {
    myHello = (import nixpkgs {
      system = "x86_64-linux";
    }).hello;
  };

}
````

```bash
nix build .#myHello --impure
warning: ... is dirty

nix build .#myHello 
warning: ... is dirty
```
Now let's just check Hello:

```bash
> result/bin/hello
Hello, world!
```

So ok, now let's look at how this would look at in a `default.nix`, so let's try to do the very same thing, so we have
the locked nix packages in here (in lock file), we have the and we build the myHello package which is just the hello
from nixpkgs. To do this, oh let's actually do first, make this agnostic over the system because this a bit, usually we
have an output schema which is like this, and now flake utils would probably be good, let's just put up the output schema
right here and do it like this, so this is not the best practice in flakes but, let's do like this:

```nix
{

  outputs = { self, nixpkgs }: {
    packages.x86_64-linux.myHello = (import nixpkgs {system = "x86_64-linux"; }).hello;
    packages.x86_64-darwin.myHello = (import nixpkgs {system = "x86_64-darwin"; }).hello;
  };
  
}
```
So you can also use flake utils for this,
