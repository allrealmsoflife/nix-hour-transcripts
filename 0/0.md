All right, well let's start super basically, I'm gonna use vim and editing the `default.nix` file, that's the file
nix evaluates by default, so let's open the file and some super basic nix stuff, let's just do like a null,
simplest value:

```nix
null
```

And then I can evaluate this, using, so there's an old way to evaluate things and a new way to evaluate things, the
old way to just evaluate the nix values is kind of convoluted, it's `nix-instantiate --eval`, ideally it should just
be `nix-eval` but legacy, `nix-instantiate --eval` and that should be it (returns `null`). Yes, so it evaluated `null`.
That's the `default.nix` file, we can also pass the file name explicitly: `nix-instantiate --eval default.nix` and 
that also works. Generally you don't have to use `nix-instantiate --eval` because in here you have like a derivation
or something, generally with nix you wanna build derivations instead of just evaluating nix itself, but yeah, let's
start with evaluation for now. 

So you have simple values, one of the main data structures in nix is the attribute set, lets add names here:

```nix
# Attribute set
{

}
```

That's just a dictionary known from almost every language out there you can have keys and values `foo = values;`, 
keys don't have to be quoted like json, there is an equal sign and a semicolon at the end. You can quote keys
as well, `"foo" = values;`, that isn't needed when you have special symbols in here for example like a dot,
`"foo.bar"` so we can evaluate this

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;
}
```

```nix
:!nix-instantiate --eval default.nix
{ foo = null; "foo.bar" = null; }
```

This evaluates to this what you see, but if we were to use this literally like this: `foo.bar = null;` this would
nested in another set, so this is, what is it, `# syntactic sugar for:` foo equals another attribute set:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
    # syntactic sugar for:
    foo = {
      bar = null;
    };
}
```

So it just nests it automatically for you, let's quote this out for now so that we don't get like conflict:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
    # syntactic sugar for:
    # foo = {
    #   bar = null;
    # };
}
```

(returns error). Oh I declared `foo` here already, so maybe that's good to see:

```nix
:!nix-instantiate --eval default.nix
error: attribute 'foo.bar' already defined at /home/infinisil/test/nix-tutorial/default.nix:3:3..
```

Foo.. OK, that's an error in nix, geez. It's starting out well (smiles). So apparently it says `foo.bar` is already defined,
but then it points to, wait..

Matthew Healy: Is it because of the string one at line 4 or?

Silvan: I don't think it should be those, it should be different, I can come to that and see, yeah now, so apparently,
that is really conflict because if we syntacticly desugar this, I guess it does make sense, you have one foo null,
and one for the attribute set, all right, so I think it was just like an error in the error message but yeah it's 
conflict, you can only define an attribute once and so that is sometimes a bit tricky to see, sometimes you have 
like a big nix file and you do like `foo.bar` somewhere and then at a later time something else with `foo =`, but
yeah, let's continue on.

We can, some other values, integers, we also can do operations with integers like addition, `int = 10 + 10;`,
division, `int = 10 + 2 / 3`, subtraction, `int = 10 + 2 / 3 - 10;`. Integer division (`/`), is like, it doesn't use
floats, this (`2 / 3`) would get zero here. And here we are coming into lazy evaluation for the first time:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    fooz.bar = null;

    int = 10 + 2 / 3 - 10;
}
```

```nix
:!nix-instantiate --eval default.nix
{ foo = null; "foo.bar" = null; fooz = <CODE>; int = <CODE>; }
```

So if we just do the `nix-instantiate --eval` it shows like a `<CODE>` here which means that it hasn't evaluated this
fully. This is a bit of a detail to how it is implemented but we can just add a `--strict` here `nix-instantiate --eval --strict`
to force it to evaluate the whole thing, so then you can see the full values here:

```nix
:!nix-instantiate --eval --strict
{ foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

There is also floats, floats aren't often used, `floats = 10 + 2 / 3 - 10;` 
but if you just add a, like a dot, `10.0`, like it converts the whole
expression to a floating thing:

```nix
:!nix-instantiate --eval --strict
{ floats = 0; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

Or, this part, `2.0`, I think you need here as well, like if there is at least one floating operation in the
pipeline it turns it into a float:

```nix
:!nix-instantiate --eval --strict 
{ floats = 0.666667; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

All right, there is a weird thing going on where it only prints the first six digits, `0.666667`, which is
often times a bit inaqurate, but, something to fix in nix. Then some other, what do we have, we have
floats, we have strings of course:

```nix
str = "foo bar";
```

Then strings can have interpolation. Certainly we need variables for this group so let's look at variables.
So variables, we can do a let in statement to declare variables so we can say, let `someVariable = 10;` 
in then the expression we want to evaluate with that variable in scope and we can say
`someVariable + 1;`

```nix
variables = 
  let someVariable = 10;
  in someVariable + 1;
```

Let's evaluate this:

```nix
:!nix-instantiate --eval --strict
{ floats = 0.666667; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; str = "foo bar";
variables = 11; }
```

It works. Let's get down a bit here. So with variables we can then also use interpolation. We'd say let
`someVariable = 10` or we need generally a, actually you don't need variables for interpolation I'm just
realizing but let's use like this for now so we can have some string, or let's say `someName = Silvan`,
in `"Hello, ${someName}";`:

```nix
interpolation = 
  let someName = "Silvan";
  in "Hello, ${someName}";
```

So this is how interpolation looks like in nix, the dollar, curly brackets, then in here, `{}`, you can
also do, like this is a general nix expression, you can put anything here, you can also add like a plus,
`{someName + }`, by the way plus is also for string concatenation, Silvan, let's add my last name here,
`${someName + " Mosberger"}";`, so you can do this, the quotes do get a bit confusing here, but the
string addition here, this is the same as just, moving Mosberger out here like this:

```nix
interpolation = 
  let someName = "Silvan";
  in "Hello, ${ someName + " Mosberger" }";
  
interpolation' = 
  let someName = "Silvan";
  in "Hello, ${ someName } Mosberger";
```

Of course, we can do then more complicated operations in here, that's any nix expression, so we can do like
`let a = 10`, and then multiple variables, just add more of them, oh you need a semicolon, `let a = 10;`,
`b = 20;`, then we can do something like, `${ a + b }`, now this will throw an error because string interpolation
needs a string so if we were to evaluate this:

```nix
interpolation'' =
  let 
    a = 10;
    b = 20;
  in "Hello, ${a + b}";
```

```nix
:!nix-instantiate --eval --strict
error: cannot coerce an integer to a string
...
```

Yeah, so this says cannot coerce an integer to a string, makes sense, we, there are builtin functions in nix
which we can call from anywhere so one of these functions is `toString`, this converts pretty much anything
to a string with some weird behaviour as well, `${ toString (a + b) }";`, parenthesis to make sure it doesn't 
just convert the first one and then this should work, (returns `interpolation'' = "Hello, 30";`), right
so `toString` useful builtin function. 

There is some, like let's use `toStringExample = toString false;`, so this is some weird behaviour,
to string of false, oh actually let's do, it's kind of hard to see the output here, (returns `toStringExample = "";`)
but if we look at this, it turns into the empty string, and that comes from bash, like yeah, makes it simple to
have that work for bash:

```nix
toStringExample = toString false;
  -- returns toStringExample = "";
toStringExample = toString true;
  -- returns toStringExample = 1;
```

Empty string and one. Yeah, but it's, it works for integers, but it also works for other things but let's get
to that later. Then what other basic things do we have. Right of course, we have attribute access or 
`attributeSelectors = ` is maybe the right way, the right word, so let's say we define some attribute set here,
let's say call it `foo = `, we can also use the dot syntax here, `foo.bar`, so `foo.bar.baz = 10;`, let's also do
like `foo.bar.qux = 20;`, right, internally nix combines these into single ones so this should be valid, and so
then we can also access the attributes of course so we can say access `in foo.bar.baz`, that's how you access
these attributes again. So this just evaluates to 10.

```nix
attributeSelectors = 
  let
    foo.bar.baz = 10;
    foo.bar.qux = 20;
  in foo.bar.baz;
```

Let's actually do like this, that's kind of easier to see:

```nix
attributeSelectors = 
  let
    foo = {
      bar.baz = 10;
      bar.qux = 20;
    };
  in foo.bar.baz;
```

All right, so this works. We can also do defaulting, `attributeSelectorsDefaulting`, where, let's say we access,
we try to access an attribute that doesn't exist `foo.bar.baz.hello`, now if we try to evaluate this we get,
`error: attribute 'hello' missing`, and so what we can do as a fallback is to you the `or` operator and we can say
`or 30`. This means that if this attribute doesn't exist just return 30.

```nix
attributeSelectorsDefaulting =
  let
    foo = {
      bar.baz = 10;
      bar.qux = 20;
    };
  in foo.bar.baz.hello or 30;
```

If we do this, we get 30 here, `attributeSelectorsDefaulting = 30;`. That also works kind of nested, that
almost works for anything actually so you could say `in foo.bar.hello.foo.bar or 30;`, that also works. Yes,
all right. That is a common gotcha because the `or` isn't the binary `or` operator, those two exist.

Let's do like `booleanOps = (true && false) || (true -> false);`, and this one we have implication `true -> false`,
and the implication is really just if the left one is true then the right one needs to be true as well, but can be
desugared to the, to this I believe `(!true || false);`, yeah it's sometimes useful. Are there any other? Oh there
is `not` of course, a exclamation mark is not, `!`, `(true && ! false)`, all right so we have that, let's see 
what would be next. We have string interpolation, we have this, variables.. functions I guess would be good next step.

So you declare functions with a colon, `someFun = x:`, so declare the name of the function argument, then a colon, and then
let's say, let's do return `x + 1;`, `x: x + 1;`, so that's like, in python it would be, do I know python? 
`def someFun(x): return x + 1..` Matthew H.: Looks good, I don't know python. 

```nix
someFun = x: x + 1;
```

And then if you want to take multiple arguments you just kind of, well one of the ways you can do it is to just to do like this,
`someFun' = x: y: x + y;`, kind of just take an argument, `x`, return a function `(y: x + y)` so this is just this, and then
you use currying to apply this so let's do like:

```nix
someFun = 
  let f = x: x + 1;
  in f 1;

someFun' =
  let f = x: y: x + y;
  in f 1 2;
```

So this, are you somewhat familiar with functional programming?

Matthew H: Yeah.

Silvan: From Haskell maybe?

Matthew H: More from Scala, but I know a bit of Haskell.

Silvan: Nice, so do you know about currying already

Matthew H.: Yes, yeah.

Silvan: Nice, nice.

Yes, so this is one way to apply multiple arguments. Another is to, arguments can be, you can take an attribute set or
destructure an attribute set as an argument so let's do `someAttrs = let f = {`, so the way you can do this is by kind
of taking an attribute set here so let's say we have `{ x, y }: x + y; in` and so this is a function that takes an attribute 
set with exactly the attributes `x` and `y` in it so this way we can do `x = 2;`, `y = 3;` and this is generally the
recommended way to declare functions because you could name arguments this way:

```nix
someFunAttrs = 
  let f = { x, y }: x + y;
  in f {
    x = 2;
    y = 3;
  };
```

And, also it's easy to add additional arguments later in a way that it doesn't brake all the code because if you were
to add the next one here `let f = x: y: z: x + y; in f 1 2;` it would just brake this and return a function whereas if
you add one here, `let f = { x, y, z }:` you get an error where `z` isn't provided.

Now these function arguments have some other capabilities, something else is you can take an elipsis, it's what it's called.
This allows you to take and ignore arbitrary other arguments, `f = {x, y, ...}:` so you could do this, how should we do this:

```nix
someFunAttrs' =
  let
    f = { x, y, ... }: x + y;
  in f {
    x = 2;
    y = 3;
    ignored = 4;
  };
```

Matthew H: If you don't have the elipsis does that mean it will only accept an attribute set with exactly `x` and `y` or?

Silvan: Exactly, yeah, if you don't provide one it will get an error, and if you provide something else it will also provide
an error. 

Matthew: OK

Silvan: Yep, right, you can also not provide one that's given here if you have a default here, this can be done with a 
question mark, `f = { x ? , y, ... }:`, so you can do like, let's give `x` a default of `1`, that's again an arbitrary nix
expression here, `f = { x ? 1, y, ... }: x + y;`, so default of `1`, and then we don't have to pass this, `x = 2`:

```nix
someFunAttrs' =
  let
    f = { x ? 1, y, ... }: x + y;
  in
    -- x = 2;
    y = 3;
    ignored = 4;
  };
```

There is some arguments against, so these defaults don't work super well sometimes, there's other ways to do this better sometimes,
let's go over this for now. So what you can also do is capture the entire attribute set that's passed here, kind of, let's say you
had something like:

```nix
someFunAttrs'' = 
  let
    f = { x ? 1, y, ... }: x + y;
    g = attrs: attrs.x + attrs.y
...
```

Oh yeah, we can like make a whole combination here so these are almost equivalent:

```nix
someFunAttrs'' =
  let
    f = { x ? 1, y, ... }: x + y;
    g = attrs: attrs.x or 1 + attrs.y
```

So the first one (`f`), explicitly destructures the attribute set, defaults `x` to `1`, `x ? 1`, then adds them, `x + y;`, and this here,
`attrs.x` accesses `x` and uses the `or` opeartor to default it to `1` and also accesses `y`, `attrs.y`, so that's a good example.
There is one slight difference where kind of destructuring of the attribute set here happens before the function even starts
evaluating, `f = { x ? 1, y, ... }:`, whereas here it doesn't happen before, `g = attrs:`, like this is just a variable, it 
doesn't get evaluated if you don't, without this. But you can also somehow combine these a bit, and that's like, let's do like,
by giving, using `attrs@`, actually that also works the other way around, this also works:

```nix
fg = attrs@{ x ? 1, y, ...}: x + y;
gf = { x ? 1, y, ... }@attrs: x + y;
```

And then you can, both get this destructuring here and you can catch kind of the attrs itself, and so this way you can,
you can do this for example `x + attrs.y`, or let's do `x + y + attrs.notIgnored;`, so that works.

Let's go to like if expression as well quick, so very basic `if true then false else true;`:

```nix
ifExpr = if true then false else true;
```

Or:

```nix
ifExpr = if 1 + 1 == 2 then "Yes" else "No";
```

And you can provide different types here as well, `else 10;`.

Matthew H.: Does the condition have to be a boolean, or is, could it be like, are the other values..

Silvan: Yes, it has to be a boolean, anything else doesn't work. Yes and so, we can also kind of combine. Sorry let's make like a,
let's say we have a function `functionMaybeArgument` where we do something like, so we declare a function, `let f = ` and we say
the function takes like an x, `{ x, `, a y, `{ x, y }`, and attrs, `{ x, y }@attrs:`, and let's do like, `attrs@: x`, well
that's also an ellipsis, `{ x, y, ...}@attrs:`, so we can get other arguments, so like `x + y +` and let's do like an
`if attrs`, oh yeah, we haven't, okay we need to first talk about something else here:

```nix
# functionMaybeArgument =
#  let f = { x, y, ... }@attrs: x + y + if attrs
```

So we can check for attributes, `checkForAttributes = `, we can do something like this, `let foo.bar.baz = 10;`, and then we can check
whether it contains a certain attribute without having to access or evaluate it, `in foo ?`, that's with the question mark operator,
so we can ask, `in foo ? bar`, does this contain `bar`? And this also works with full paths, `bar.baz`, so we can say does this contain
`bar`, and does `bar` contain `baz`? And so in this case this would evaluate to true. This, `in foo ? bar.foo;` would evaluate to false,
and so on:

```nix
checkForAttributes =
  let foo.bar.baz = 10;
  in foo ? bar.baz;
```

And so this way in here 23.32

