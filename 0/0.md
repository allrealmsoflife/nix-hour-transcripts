All right, well let's start super basically, I'm gonna use vim and editing the `default.nix` file, that's the file
nix evaluates by default, so let's open the file and some super basic nix stuff, let's just do like a null,
simplest value:

```nix
null
```

And then I can evaluate this, using, so there's an old way to evaluate things and a new way to evaluate things, the
old way to just evaluate the nix values is kind of convoluted, it's `nix-instantiate --eval`, ideally it should just
be `nix-eval` but legacy, `nix-instantiate --eval` and that should be it (returns `null`). Yes, so it evaluated `null`.
That's the `default.nix` file, we can also pass the file name explicitly: `nix-instantiate --eval default.nix` and 
that also works. Generally you don't have to use `nix-instantiate --eval` because in here you have like a derivation
or something, generally with nix you wanna build derivations instead of just evaluating nix itself, but yeah, let's
start with evaluation for now. 

So you have simple values, one of the main data structures in nix is the attribute set, lets add names here:

```nix
# Attribute set
{

}
```

That's just a dictionary known from almost every language out there you can have keys and values `foo = values;`, 
keys don't have to be quoted like json, there is an equal sign and a semicolon at the end. You can quote keys
as well, `"foo" = values;`, that isn't needed when you have special symbols in here for example like a dot,
`"foo.bar"` so we can evaluate this

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;
}
```

```nix
:!nix-instantiate --eval default.nix
{ foo = null; "foo.bar" = null; }
```

This evaluates to this what you see, but if we were to use this literally like this: `foo.bar = null;` this would
nested in another set, so this is, what is it, `# syntactic sugar for:` foo equals another attribute set:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
    # syntactic sugar for:
    foo = {
      bar = null;
    };
}
```

So it just nests it automatically for you, let's quote this out for now so that we don't get like conflict:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
    # syntactic sugar for:
    # foo = {
    #   bar = null;
    # };
}
```

(returns error). Oh I declared `foo` here already, so maybe that's good to see:

```nix
:!nix-instantiate --eval default.nix
error: attribute 'foo.bar' already defined at /home/infinisil/test/nix-tutorial/default.nix:3:3..
```

Foo.. OK, that's an error in nix, geez. It's starting out well (smiles). So apparently it says `foo.bar` is already defined,
but then it points to, wait..

Matthew Healy: Is it because of the string one at line 4 or?

Silvan: I don't think it should be those, it should be different, I can come to that and see, yeah now, so apparently,
that is really conflict because if we syntacticly desugar this, I guess it does make sense, you have one foo null,
and one for the attribute set, all right, so I think it was just like an error in the error message but yeah it's 
conflict, you can only define an attribute once and so that is sometimes a bit tricky to see, sometimes you have 
like a big nix file and you do like `foo.bar` somewhere and then at a later time something else with `foo =`, but
yeah, let's continue on.

We can, some other values, integers, we also can do operations with integers like addition, `int = 10 + 10;`,
division, `int = 10 + 2 / 3`, subtraction, `int = 10 + 2 / 3 - 10;`. Integer division (`/`), is like, it doesn't use
floats, this (`2 / 3`) would get zero here. And here we are coming into lazy evaluation for the first time:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    fooz.bar = null;

    int = 10 + 2 / 3 - 10;
}
```

```nix
:!nix-instantiate --eval default.nix
{ foo = null; "foo.bar" = null; fooz = <CODE>; int = <CODE>; }
```

So if we just do the `nix-instantiate --eval` it shows like a `<CODE>` here which means that it hasn't evaluated this
fully. This is a bit of a detail to how it is implemented but we can just add a `--strict` here `nix-instantiate --eval --strict`
to force it to evaluate the whole thing, so then you can see the full values here:

```nix
:!nix-instantiate --eval --strict
{ foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

There is also floats, floats aren't often used, `floats = 10 + 2 / 3 - 10;` 
but if you just add a, like a dot, `10.0`, like it converts the whole
expression to a floating thing:

```nix
:!nix-instantiate --eval --strict
{ floats = 0; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

Or, this part, `2.0`, I think you need here as well, like if there is at least one floating operation in the
pipeline it turns it into a float:

```nix
:!nix-instantiate --eval --strict 
{ floats = 0.666667; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

All right, there is a weird thing going on where it only prints the first six digits, `0.666667`, which is
often times a bit inaqurate, but, something to fix in nix. Then some other, what do we have, we have
floats, we have strings of course:

```nix
str = "foo bar";
```

Then strings can have interpolation. Certainly we need variables for this group so let's look at variables.
So variables, we can do a let in statement to declare variables so we can say, let `someVariable = 10;` 
in then the expression we want to evaluate with that variable in scope and we can say
`someVariable + 1;`

```nix
variables = 
  let someVariable = 10;
  in someVariable + 1;
```

Let's evaluate this:

```nix
:!nix-instantiate --eval --strict
{ floats = 0.666667; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; str = "foo bar";
variables = 11; }
```

It works. Let's get down a bit here. So with variables we can then also use interpolation. We'd say let
`someVariable = 10` or we need generally a, actually you don't need variables for interpolation I'm just
realizing but let's use like this for now so we can have some string, or let's say `someName = Silvan`,
in `"Hello, ${someName}";`:

```nix
interpolation = 
  let someName = "Silvan";
  in "Hello, ${someName}";
```

So this is how interpolation looks like in nix, the dollar, curly brackets, then in here, `{}`, you can
also do, like this is a general nix expression, you can put anything here, you can also add like a plus,
`{someName + }`, by the way plus is also for string concatenation, Silvan, let's add my last name here,
`${someName + " Mosberger"}";`, so you can do this, the quotes do get a bit confusing here, but the
string addition here, this is the same as just, moving Mosberger out here like this:

```nix
interpolation = 
  let someName = "Silvan";
  in "Hello, ${ someName + " Mosberger" }";
  
interpolation' = 
  let someName = "Silvan";
  in "Hello, ${ someName } Mosberger";
```

Of course, we can do then more complicated operations in here, that's any nix expression, so we can do like
`let a = 10`, and then multiple variables, just add more of them, oh you need a semicolon, `let a = 10;`,
`b = 20;`, then we can do something like, `${ a + b }`, now this will throw an error because string interpolation
needs a string so if we were to evaluate this:

```nix
interpolation'' =
  let 
    a = 10;
    b = 20;
  in "Hello, ${a + b}";
```

```nix
:!nix-instantiate --eval --strict
error: cannot coerce an integer to a string
...
```

Yeah, so this says cannot coerce an integer to a string, makes sense, we, there are builtin functions in nix
which we can call from anywhere so one of these functions is `toString`, this converts pretty much anything
to a string with some weird behaviour as well, `${ toString (a + b) }";`, parenthesis to make sure it doesn't 
just convert the first one and then this should work, (returns `interpolation'' = "Hello, 30";`), right
so `toString` useful builtin function. 

There is some, like let's use `toStringExample = toString false;`, so this is some weird behaviour,
to string of false, oh actually let's do, it's kind of hard to see the output here, (returns `toStringExample = "";`)
but if we look at this, it turns into the empty string, and that comes from bash, like yeah, makes it simple to
have that work for bash:

```nix
toStringExample = toString false;
  -- returns toStringExample = "";
toStringExample = toString true;
  -- returns toStringExample = 1;
```

Empty string and one. Yeah, but it's, it works for integers, but it also works for other things but let's get
to that later. Then what other basic things do we have. Right of course, we have attribute access or 
`attributeSelectors = ` is maybe the right way, the right word, so let's say we define some attribute set here,
let's say call it `foo = `, we can also use the dot syntax here, `foo.bar`, so `foo.bar.baz = 10;`, let's also do
like `foo.bar.qux = 20;`, right, internally nix combines these into single ones so this should be valid, and so
then we can also access the attributes of course so we can say access `in foo.bar.baz`, that's how you access
these attributes again. So this just evaluates to 10.

```nix
attributeSelectors = 
  let
    foo.bar.baz = 10;
    foo.bar.qux = 20;
  in foo.bar.baz;
```

Let's actually do like this, that's kind of easier to see:

```nix
attributeSelectors = 
  let
    foo = {
      bar.baz = 10;
      bar.qux = 20;
    };
  in foo.bar.baz;
```

All right, so this works. We can also do defaulting, `attributeSelectorsDefaulting`, where, let's say we access,
we try to access an attribute that doesn't exist `foo.bar.baz.hello`, now if we try to evaluate this we get,
`error: attribute 'hello' missing`, and so what we can do as a fallback is to you the `or` operator and we can say
`or 30`. This means that if this attribute doesn't exist just return 30.

```nix
attributeSelectorsDefaulting =
  let
    foo = {
      bar.baz = 10;
      bar.qux = 20;
    };
  in foo.bar.baz.hello or 30;
```

If we do this, we get 30 here, `attributeSelectorsDefaulting = 30;`. That also works kind of nested, that
almost works for anything actually so you could say `in foo.bar.hello.foo.bar or 30;`, that also works. Yes,
all right. That is a common gotcha because the `or` isn't the binary `or` operator, those two exist.

Let's do like `booleanOps = (true && false) || (true -> false);`, and this one we have implication `true -> false`,
and the implication is really just if the left one is true then the right one needs to be true as well, but can be
desugared to the, to this I believe `(!true || false);`, yeah it's sometimes useful. Are there any other? Oh there
is `not` of course, a exclamation mark is not, `!`, `(true && ! false)`, all right so we have that, let's see 
what would be next. We have string interpolation, we have this, variables.. functions I guess would be good next step.

So you declare functions with a colon, `someFun = x:`, so declare the name of the function argument, then a colon, and then
let's say, let's do return `x + 1;`, `x: x + 1;`, so that's like, in python it would be, do I know python? 
`def someFun(x): return x + 1..` Matthew H.: Looks good, I don't know python. 

```nix
someFun = x: x + 1;
```

And then if you want to take multiple arguments you just kind of, well one of the ways you can do it is to just to do like this,
`someFun' = x: y: x + y;`, kind of just take an argument, `x`, return a function `(y: x + y)` so this is just this, and then
you use currying to apply this so let's do like:

```nix
someFun = 
  let f = x: x + 1;
  in f 1;

someFun' =
  let f = x: y: x + y;
  in f 1 2;
```

So this, are you somewhat familiar with functional programming?

Matthew H: Yeah.

Silvan: From Haskell maybe?

Matthew H: More from Scala, but I know a bit of Haskell.

Silvan: Nice, so do you know about currying already

Matthew H.: Yes, yeah.

Silvan: Nice, nice.

Yes, so this is one way to apply multiple arguments. Another is to, arguments can be, you can take an attribute set or
destructure an attribute set as an argument so let's do `someAttrs = let f = {`, so the way you can do this is by kind
of taking an attribute set here so let's say we have `{ x, y }: x + y; in` and so this is a function that takes an attribute 
set with exactly the attributes `x` and `y` in it so this way we can do `x = 2;`, `y = 3;` and this is generally the
recommended way to declare functions because you could name arguments this way:

```nix
someFunAttrs = 
  let f = { x, y }: x + y;
  in f {
    x = 2;
    y = 3;
  };
```

And, also it's easy to add additional arguments later in a way that it doesn't brake all the code because if you were
to add the next one here `let f = x: y: z: x + y; in f 1 2;` it would just brake this and return a function whereas if
you add one here, `let f = { x, y, z }:` you get an error where `z` isn't provided.

Now these function arguments have some other capabilities, something else is you can take an elipsis, it's what it's called.
This allows you to take and ignore arbitrary other arguments, `f = {x, y, ...}:` so you could do this, how should we do this:

```nix
someFunAttrs' =
  let
    f = { x, y, ... }: x + y;
  in f {
    x = 2;
    y = 3;
    ignored = 4;
  };
```

Matthew H: If you don't have the elipsis does that mean it will only accept an attribute set with exactly `x` and `y` or?

Silvan: Exactly, yeah, if you don't provide one it will get an error, and if you provide something else it will also provide
an error. 

Matthew: OK

Silvan: Yep, right, you can also not provide one that's given here if you have a default here, this can be done with a 
question mark, `f = { x ? , y, ... }:`, so you can do like, let's give `x` a default of `1`, that's again an arbitrary nix
expression here, `f = { x ? 1, y, ... }: x + y;`, so default of `1`, and then we don't have to pass this, `x = 2`:

```nix
someFunAttrs' =
  let
    f = { x ? 1, y, ... }: x + y;
  in
    -- x = 2;
    y = 3;
    ignored = 4;
  };
```

There is some arguments against, so these defaults don't work super well sometimes, there's other ways to do this better sometimes,
let's go over this for now. So what you can also do is capture the entire attribute set that's passed here, kind of, let's say you
had something like:

```nix
someFunAttrs'' = 
  let
    f = { x ? 1, y, ... }: x + y;
    g = attrs: attrs.x + attrs.y
...
```

Oh yeah, we can like make a whole combination here so these are almost equivalent:

```nix
someFunAttrs'' =
  let
    f = { x ? 1, y, ... }: x + y;
    g = attrs: attrs.x or 1 + attrs.y
```

So the first one (`f`), explicitly destructures the attribute set, defaults `x` to `1`, `x ? 1`, then adds them, `x + y;`, and this here,
`attrs.x` accesses `x` and uses the `or` opeartor to default it to `1` and also accesses `y`, `attrs.y`, so that's a good example.
There is one slight difference where kind of destructuring of the attribute set here happens before the function even starts
evaluating, `f = { x ? 1, y, ... }:`, whereas here it doesn't happen before, `g = attrs:`, like this is just a variable, it 
doesn't get evaluated if you don't, without this. But you can also somehow combine these a bit, and that's like, let's do like,
by giving, using `attrs@`, actually that also works the other way around, this also works:

```nix
fg = attrs@{ x ? 1, y, ...}: x + y;
gf = { x ? 1, y, ... }@attrs: x + y;
```

And then you can, both get this destructuring here and you can catch kind of the attrs itself, and so this way you can,
you can do this for example `x + attrs.y`, or let's do `x + y + attrs.notIgnored;`, so that works.

Let's go to like if expression as well quick, so very basic `if true then false else true;`:

```nix
ifExpr = if true then false else true;
```

Or:

```nix
ifExpr = if 1 + 1 == 2 then "Yes" else "No";
```

And you can provide different types here as well, `else 10;`.

Matthew H.: Does the condition have to be a boolean, or is, could it be like, are the other values..

Silvan: Yes, it has to be a boolean, anything else doesn't work. Yes and so, we can also kind of combine. Sorry let's make like a,
let's say we have a function `functionMaybeArgument` where we do something like, so we declare a function, `let f = ` and we say
the function takes like an x, `{ x, `, a y, `{ x, y }`, and attrs, `{ x, y }@attrs:`, and let's do like, `attrs@: x`, well
that's also an ellipsis, `{ x, y, ...}@attrs:`, so we can get other arguments, so like `x + y +` and let's do like an
`if attrs`, oh yeah, we haven't, okay we need to first talk about something else here:

```nix
# functionMaybeArgument =
#  let f = { x, y, ... }@attrs: x + y + if attrs
```

So we can check for attributes, `checkForAttributes = `, we can do something like this, `let foo.bar.baz = 10;`, and then we can check
whether it contains a certain attribute without having to access or evaluate it, `in foo ?`, that's with the question mark operator,
so we can ask, `in foo ? bar`, does this contain `bar`? And this also works with full paths, `bar.baz`, so we can say does this contain
`bar`, and does `bar` contain `baz`? And so in this case this would evaluate to true. This, `in foo ? bar.foo;` would evaluate to false,
and so on:

```nix
checkForAttributes =
  let foo.bar.baz = 10;
  in foo ? bar.baz;
```

And so this way in here we can check whether `attrs ?` contains like `notIgnored`, or `maybeIgnored`, or actually `notIgnored`,
so we check whether it contains a `notIgnored`, if it does contain that, `then`, let's go to new line here, ok formatting is a
bit messy, if attrs contains one of these attributes then we can say, let's also add `attrs.notIgnored else 0;`, in
`f { x = 1; y = 2; notIgnored = 3; };`, yeah so that works:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }attrs@:
      x + y + if attrs ? notIgnored then attrs.notIgnored else 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

And I'm just realizing that that's actually the same as this, as `attrs.notIgnored or 0`:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }@attrs:
      x + y + if attrs ? notIgnored then attrs.notIgnored else 0;
    f = { x, y, ... }@attrs:
      x + y + attrs.notIgnored or 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

I'm not sure about the precedence here actually (`.. + if ..`), let's try to evaluate this, maybe it will fail:

```nix
:!nix-instantiate --eval --strict
error: syntax error, unexpected IF ..
```

Yep, that does fail, so we need a parenthesis here:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }@attrs:
      x + y + (if attrs ? notIgnored then attrs.notIgnored else 0);
    f = { x, y, ... }@attrs:
      x + y + attrs.notIgnored or 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

```nix
:!nix-instantiate --eval --strict
error: attribute 'f' already defined..
```

Oh, and `f`'s already defined:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }@attrs:
      x + y + (if attrs ? notIgnored then attrs.notIgnored else 0);
    f' = { x, y, ... }@attrs:
      x + y + attrs.notIgnored or 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

Okay, we have evaluation working again. Yes so that's mainly functions. Something to point out here, it's a bit of a quirk
in nix is that `functionDefaultsQuirk = let f`, let's say you have a, well it goes a bit too deep maybe already, but let's
say you have some defaulting argument here, `let f = { x ? 10 }`, and then you do like `@attrs:`, and then you try to check
whether attrs contains x, `attrs ? x;`, now what's, `in`, it's kind of a interesting question what, or let's also do like,
`in f {}`, so attrs here, `(@attrs:)`, doesn't do anything regarding like these defaults, `{ x ? 10 }`, attrs is literally
just the thing you pass in, `f {}`, and so if you don't pass an x here, `{ x ? 10 }`, even though you can like use this 
`x` variable here, `x attrs ?`, the check here will fail, it won't contain an `x`, let's evaluate this:

```nix
functionDefaultsQuirk = 
  let f = { x ? 10 }@attrs: attrs ? x;
  in f {};
```

```nix
:!nix-instantiate --eval --strict
..functionDefaultsQuirk = false;
```

Yeah, it's false, yeah and so that's a bit of a catch. 

Yeah and, maybe we can look at some builtin functions. `builtinsFuns = `, so there is, we have functions like, so pretty much
all of these are accessible under `builtins.`, that's kind of the builtins operator, also `builtins.toString;` is here, we have,
oh lists, we haven't checked out lists, I'm just realizing, but yeah, lists are just the normal thing, but something to point out
is that elements are separated by spaces so if we were to make a list of functions here, `a = [ builtins.toString builtins.map ];`
you'd have to separate them by spaces and not add any commas so:

```nix
a = [
  builtins.toString
  builtins.map
  builtins.partition
];
```

There's a whole bunch of these. We can also look at these in nix repl, maybe that's actually a good point to mention, let's switch to the
nix repl real quick, (`nix repl`), we can, (`nix-repl> builtins`), we also have auto completion here so that's nice, 
`builtins.` and yeah I can see all the builtins (scrolling through), there is a whole bunch, there is to check the 
types of expressions, there's like builtins to map attribute sets, oh yeah, that's (`builtins.match`) a regex matching thing,
string processings, `builtins.false` interesting, (`builtins.toJSON`), to json, there is also from json, to read json
into a nix attribute set.

Yeah, I think, (`vim default.nix`), did I get the most of the nix, I don't know, maybe let's use a simple map here, 
(`a = [ builtins.toString builtins.map builtins.partition ];`). Let's do like numbers one, two, three in a list,
`a = [ 1 2 3 ];`, and let's do like a `builtins.map [ 1 2 3 ];`, and let's do like, let's give a function here,
`builtins.map (x: [ 1 2 3];`, let's say like `x` plus one, `builtins.map (x: x + 1) [ 1 2 3 ];`, `in a;`, and so
that works, adds x to all the numbers:

```nix
builtinFuns =
  let
    a = builtins.map (x: x + 1) [ 1 2 3 ];
  in a;
```

It's fairly self-explanatory. There's also some weird thing where you don't actually need `builtins.` for some 
builtins so map is one of them, `a = map (x: x + 1) [ 1 2 3 ];`, `map` is valid on it's own, so you'll see
it sometimes just like that without any reference where does it come from. `toString` we saw that as well,
`toString` doesn't need the `builtins.` but most builtins do need that prefix. 

Maybe, what do you think of this, are you confused about anything or do you have a good overview?

Matthew H.: No, that makes a lot of sense so far. 

Silvan: All right, nice, then I think let's maybe go into derivations, um derivations are a bit of a hard topic
because yeah but I guess It's fine, let's do like just a little bit about the `derivationPrimitive =`, or the
`derivationBuiltin =`. So there is some derivation,

```nix
derivationBuiltin =
  let
    someDerivation =
  in null;  
```

There is the `builtins.derivation` and this creates a derivation and what is a derivation, it's a build recipe,
and there's some very basic arguments that you need to pass to actually make that work. Let's see, if we just 
do this we should get an error:

```nix
derivationBuiltin =
  let 
    someDerivation = builtins.derivation {
    
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
error: attribute 'name' missing for call to 'derivationStrict'..
```

Attribute name missing for call, the error is again a bit messed up, but let's roll with it for now,
so derivations need a name, let's call this test:

```nix
derivationBuiltin = 
  let
    someDerivation = builtins.derivation {
      name = test;
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
error: required attribute 'builder' missing
```

They also need a builder attribute. This says which binary will build the derivation, now this is a bit hacky here, I'm just
gonna use `/bin/sh` which is one of the only binaries available in the sandbox on I think all systems:

```nix
derivationBuiltin = 
  let 
    someDerivation = builtins.derivation {
      name = "test";
      builder = "/bin/sh";
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
error: required attribute 'system' missing..
```

Um, then also a system is needed, `system =`, I'm gonna use `"x86_64-linux";` the system I'm on right now, so linux:

```nix
derivationBuiltin =
  let
    someDerivation = builtins.derivation {
      name = "test";
      builder = "/bin/sh/";
      system = "x86_64-linux";
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
```

And now that actually works. We can't really see the xoutputs super well here, I wanna re-format this a bit,
let me do like a, let's convert this entire attribute set into a let statement (goes to the top) and then add
an `in` at the end and do a `derivationBuiltin` here, so it will declare all the things we have above but only
result in this `derivationBuiltin` thing:

```nix
# Attribute set
let
  foo = null;
  -- all the way to the end of default.nix`

  derivationBuiltin = 
    let
      someDerivation = builtins.derivation {
        name = "test";
        builder = "/bin/sh";
        system = "x86_64-linux";
      };
    in someDerivation;
in derivationBuiltin
```

```nix
nix-instantiate --eval --strict
{ all = [ <<repeated>> ]; builder = "/bin/sh"; drvAttrs = { builder = "/bin/sh"; name = "test"; system =..
```

So yeah, we get this output, so what this really does underneath is that it takes all these arguments, calls
some internal nix primitive which creates a derivation in the actual store, that's this path here,
`drvPath = "/nix/store/y1s2..-test.drv";`, and it also tells us the output path, `outPath = "..";`, so this
means when you build this derivation description and we can look at this, actually no we can't look at it yet because,
oh, kind of a quirk, `--eval` evaluates it in like a read-only mode which doesn't write anything to the nix store.
We can do `--read-write` mode to enable this, (`nix-instantiate --eval --strict --read-write`) I believe. Ok now
we should be able to look at the store path here, we can just `cat /nix/store/y1s2..-test.drv` this path and it's
like a kind of simple description of how derivation gets built, there is like output path where should the derivation
put the result when it runs, what system is it in, the builder, and the environment (`("name", "test")`, ah actually
not, the name out, some very basic things.

Now we can call `nix-store -r`, this stands for `--realize`, you can call this to kind of manually build this derivation:

```nix
> nix-store --realize /nix/store/y1s2..-test.drv
```

Generally you don't need this but let's just go for it for now. If we try to build this it doesn't really do anything:

```nix
this derivation will be built:
  /nix/store..-test.drv
building...
error: builder for ... failed to produced output path for output 'out' at ..
```

Nix throws an error because we just called bin shell, it doesn't write the output here. 

```nix
cat /nix/store/..-test.drv
Derive([("out","/nix/store/d62..-test","","")]..
```

Okay? And so usually here, what we did now is this weird thing, `nix-instantiate --eval`, `--strict` isn't needed here,
`nix-instantiate --eval --read-write-mode` and this can then be copied, actually we do need `--strict`, then we 
copy the `..-test.drv` path, it's super convoluted and then we like the, `nix-store --realize ..`. Easier way, you
can just do `nix-build`, that's really just what nix build does. And so if you do that it will evaluate it and try
to build it in one step.

And so, also I think we can just nix instantiate it to get the derivation path

```nix
nix-instantiate
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/y1..-test.drv
```

So nix instantiate just kind of instantiates the derivation. Instantiating means to evaluate a derivation and
produce it in the store, so that this file, (`/nix/store/..-test.drv`), actually exists. `nix-build` is essentially
just:

```nix
nix-build = nix-instantiate + nix-store --realize
```

It first creates a derivation, and then tries to realize or slash build the derivation. And so let's try to fix this 
derivation in here, there's other arguments we can pass, there's some special ones, like `args` where we can provide
arguments to the builder, (`args = [ " `), and in here we're gonna do `-c` and like this maybe, `> $out"`:

```nix
-- ..
builder = "/bin/sh";
args = [ "-c" "> $out" ];
system = "x86_64-linux";
-- ..
```

So this says, shell, take a script, execute the script, and the script writes an empty file to the `out` variable, and 
in the builder the out environment variable points to the output path that nix wants you to write stuff and so this
should at least produce an empty result and build properly, let's see, that's super slow for some reason. Okay, it worked.

```nix
> nix-build
this derivation will be built:
```

So we can `ls` this (`/nix/store/..-test.drv`) I guess but it won't show anything because we didn't try anything but now
here (`vim default.nix`), we can of course do anything we want, well of course there's more complicated things, but for now,
let's do like a, can I do like.. would that work? (`args = [ "-c" "> $out <<< foo" ];`, I'm not sure that's valid shell,
`nix-build`, nope, that doesn't work. Well I don't know how to write to a file, bin shell, well I guess that can work, like
a `echo foo > $out`, all right, `nix-build`, `ls` as before, it's a file, but yeah, if we do a `cat /nix/store..-test.drv` we 
get `foo` now.

And so when you `nix-build` it puts a result symlink in your current directory, `result -> /nix/store..-test`, pointing 
to the thing it just built. As this way you can just `cat result` as well and inspect the result this way. It's not
always result so you need to watch how to, like there is some special features that change the output link name 37:59
