Silvan: Yeah, so since you asked this just before Simonas do you want to repeat the question?

Question: Yeah, I can repeat it, so what I've been doing, like I've been trying to play a Valorian
game, like the Rust open source game, and the launcher is running on 0.7 and I thought I will just
override it to 0.9, make a derivation and then as I started doing the derivation I came across this
problem with cargo sha256 that I did not know how to calculate it out.

Silvan: Yeah, so the question is how to update rust packages to, how to override rust packages with
newer versions well, yeah I guess that's the question, and then there's the problem of the dependency
hash not being updated automatically.

Simonas: Yeah, so making a derivation carg sha256 needs to be additionally also kind of like recalculated

Silvan: Yeah, which package did you try it on

Simonas: airshipper

Silvan: OK

```nix
nix-instantiate -A airshipper.version
error: expression does not evaluate to a derivation (or a set or list of those)
```

Okay, so do you want to use, let's use:

```nix
ne -A airshipper.version
"0.7.0"
```

And you wanted to get a newer version?

Simonas: 0.9.0

Silvan: Yeah, okay, let's I guess try it out there so, let's try to write an overlay, I'm just gonna write this
locally in my nixpkgs here:

```bash
vim overlay.nix
```
So `self: super: { }` we could also use alternative, the others are `final:` and `prev:`, it's really kind of just
convention, you can name them anything you want, then `airshipper = `, so by default usually you do something like 
this, `super.airshipper`, and then `.overrideAttrs`, because you want to override the src attribute and that's part
of the derivation attributes, so that's what `overrideAttrs` overrides. Then we get in here the `(old: ` attributes
from the derivation and can provide new ones, so here we say `src = `, well now got to figure out how it gets fetched:

```nix
# final: prev:
self: super: {
  airshipper = super.airshipper.overrideAttrs (old: {
    src =
  });
}
```

Let me go into nixpkgs here, (`~/src/nixpkgs`), go to airshipper, look at how that's packaged, we see `src = fetchFromGitLab`,
okay, that looks good, we go back here and just copy that in:

```nix
self: super: {
  airshipper = super.airshipper.overrideAttrs (old: {
    src = fetchFromGitLab {
        owner = "Veloren";
        repo = "airshipper";
        rev = "v${version}";
        hash = "sha256-V8G1mZIdqf+WGcrUzRgWnlUk+EXs4arAEQdRESpobGg=";
    };
  });
}
```

Let me do, `0.9.0`, and I guess we can also do this here version, well let's put the version here, and I think if we 
don't update the name here it will keep the same derivation name, let's see what happens, and here we need to use
`rec` I believe, we talked about this in a previous video where there is a new convention in nixpkgs which doesn't
require the `rec` anymore, the video there was a bit misleading because most derivations don't use the new convention
yet so in most cases this is still needed so `old.version` would still be 0.7.0 here, not the 0.9.0, so for now
I'm just gonna use the old convention with `rec` and then the `sha` we need to update it a bit, so it causes a refetch,
let me just change a character here, we can also clear it, yeah let's do that.

Julien Debon: Or you can use an empty string right?

Silvan: Um, yeah, I wonder if just not specifying also works, if that's the same as an empty string, I guess we can try 
it out here:

```nix
self: super: {
  airshipper = super.airshipper.overrideAttrs (old: rec {
    version = "0.9.0";
    src = fetchFromGitLab {
        owner = "Veloren";
        repo = "airshipper";
        rev = "v${version}";
        # hash = "sha256-V8G1mZIdqf+WGcrUzRgWnlUk+EXs4arAEQdRESpobGg=";
    };
  });
}
```

Viktor Kleen: What I usually do, is I say `sha256` is `self.lib.fakehash`

Silvan: Yeah that, I think nowadays that's not really required anymore because just an empty sha also works, this is a 
somewhat recent feature in nix as far as I know, and the `lib.` what is, `lib.fakeSha256`, I think that was introduced
before nix allowed empty sha's.

Viktor Kleen: You can also do the fakehash, fakehash is just the new, the sri hash string.

Silvan: I see, nice. Yeah, let's try to do that for now, I'm gonna try to do the build here:

```bash
:!nix-build -A airshipper
```

And it works, so apparently this didn't work at all, is it because I didn't provide a hash here? Or is it cargo sha 256, oh
it is because we haven't applied the overlay, I just wrote it in my local directory here. So I'm using the old CLI here,
we are in a nixpkgs checkout, you can build packages like this (`nix-build -A airshipper`), but this doesn't apply the
overlay automatically. We could move the overlay to:

```bash
mv overlay.nix ~/.config/nixpkgs/overlays/airshipper.nix
```

We need to create the directory first, `mkdir ~/.config/nixpkgs/overlays -p`, move it in there, so this is impure,
I see Yuri mentions in the chat so this is impure, so flakes doesn't work with this. Flakes would just ignore this.
I'm gonna show this without relying on this in a second

```nix
nix-build -A airshipper
error: undefined variable 'fetchFromGitLab`
```

Okay, we get an error because I made a mistake in the file but it gets evaluated, so let's fix it here, we need to use:

```nix
self: super: {
  airshipper = super.airshipper.overrideAttrs (old: {
    src = self.fetchFromGitLab {
        owner = "Veloren";
        repo = "airshipper";
        rev = "v${version}";
        sha256 = "";
    };
  });
}
```

Let's try to evaluate it again:

```nix
nix-build -A airshipper
warning: found empty hash, assuming 'sha256-AA..='
```

And okay, we can see it inferred from the empty hash, and did we provide one? We did provide one, we also want to see if
it works without any hash at all, (`# sha256 ="";`), yeah that also works, okay that's good news. You do need to watch out
a bit if you use `fetchTarball` without the hash, so this a builtin fetcher, (`builtin.fetchTarball {}`), and we could
also try this out here so let's say `src = fetchTarball {};` and then we use 
```nix
url = "https://github.com/Veloren/airshipper/archive/v0.9.0.tar.gz";
```

Julien Debon: I think it's gitlab not github.

Silvan: Oh it's gitlab all right.

Simone Narbutas: It's mirrored though.

Silvan: It does turn into the same url?

Simone Narbuta: It should be the same on github, like as far as I know

Silvan: Okay, let's try this then

```nix
self: super: {
  airshipper = super.airshipper.overrideAttrs (old: rec {
    version = "0.9.0";
    # src = self.fetchFromGitLab {
    #    owner = "Veloren";
    #    repo = "airshipper";
    #    rev = "v${version}";
    #    sha256 = "";
    #};
    src = fetchTarball {
      url = "https://gitlab.com/Veloren/airshipper/archive/v0.9.0.tar.gz";
    };
  });
}
```

So now, `nix-build -A airshipper`, so this, oh, that looked like an error, it's another url I believe..

Yuriy Taraday: Try github instead of gitlab

Silvan: Oh.. I see. That should make it work then. Ok we can see here we didn't get an error, even though we didn't provide a hash,
so this is a difference between the nixpkgs fetchers which don't work without a hash at all, well they shouldn't work
without a hash, nix does allow this warning when you don't provide a hash, but obviously you are gonna fix it when you see it.
The builtin fetchers don't need a hash and they're just gonna download these files impurely so we have to explicitly provide
a hash here, I think we can also just do `hash = "";`, let's try this:

```nix
nix-build -A airshipper
error: unsupported argument 'hash' to 'fetchTarball'
```

Fair enough, `fetchTarball` apparently doesn't have a hash, all right let's make it, that's unfortunate: `sha256 = "";`:

```nix
nix-build -A airshipper
warning: found empty hash, assuming 'sha256..='
```

This time it works, this time it gets the same result as the `fetchFromGitlab`, in that it assumes the empty zero hash.
Yeah, so I guess it might be good to always set the hash to an empty string (`sha256 = "";`) so that you don't run into
these cases where the nix packages fetchers do need them but those don't and yeah, anyways, let's go back to this, so
we get the hash back from this. As soon as it's downloaded.. it's quite a bit project seemingly, there we go, oh it
dissapeared, oh it's downloading it again.

Simon Narbutas: This should be just a launcher, so it shouldn't be a big.

Silvan: Mhm, might also just be slow for some reason then. All right I copied the hash, and insert here, and here maybe
we can also use hash, (`hash = "sha256-...=";`), oh it doesn't really matter, both of them work the same way. All right so
that works, let's try to build it. All right and now we get a patch error. Let's see it might be good to look into that and 
see what happens. Well but first I want to do this kind of overlay kind of purification in a way. So let's try to build 
this with with a flake way, so let's use the new nix CLI, let's try to build airshipper in nixpkgs here,
(`nix build .#airshipper`), this should work but give the old version, it shouldn't take a look at the overlay here, and yeah
if we look into the directory, (`result -> /nix/store/z..-airshipper-0.7.0`). Oh, and actually, oh, we can't pass in the
overlay from the CLI here, that's right, because flakes doesn't support `--arg` and `--argstr` yet,
(`nix build .#airshipper --argstr`). Uhm, fair enough, so I guess with flakes you'd have to write a `flake.nix` to import
nixpkgs with the overlay you want, (`vim flake.nix`), uhm, or with traditional nix you could also do this, `(nix-build -A airshipper`)
to make it pure. Let's move it back from nixpkgs, (`mv ~/.config/nixpkgs/overlays/airshipper.nix .`) to the local directory
for now, we can also do this, (`nix-build -A airshipper --arg overlays`), we can provide `--arg overlays` so this is,
if you import nixpkgs you can pass the overlays attribute, you can pass all the overlays in the overlays attribute, and
we can also do this from the command line so we can give the array of overlays here, here we can just say:

```nix
nix-build -A airshipper --arg overlays '[ (import ./airshipper.nix) ]'
```

And this then gives the same result without the impurity of looking it up in the `.config` directory. So let's see how far
does it get here. Well in the end it will also fetch the old, oh yeah, look here, the vendor directory is still 0.7.0.
Might be cause by the name but I don't think so, but let's update the name as well, well let's just see what the name
currently is. Let's do..

Viktor Kleen: The name looks all right, right, from the derivation?

Silvan: Oh yeah, it does look all right. Interesting, so that gets propagated automatically, in this case we don't need it.
All right, then, well.. let's also try to override this one..

Viktor Kleen: I think that's because of the.. package the pname, the version already, the name get's me confused.

Silvan: I do think that underneath there sometimes still was a problem because the kind of pname and version was only,
was kind of transformed to the name underneath and but only in the original make derivation call or something. Maybe not
though, I guess that works.

Simonas Narbutas: But I was trying to figure out what pulls in this dash vendor, does it come from the rust package function or?

Silvan: Yeah, let's look at how it's implemented underneath. So the airshipper, let's go back to airshipper here, so airshipper
uses `rustPlatform.buildRustPackage` and so what is then here, so yeah, it's this hash here, (`cargoSha256`), that is kind of
the problem, so I guess, let's take a look at `buildRustPackage`.

So how to find things in nixpkgs is always a bit of a gamble but I like to just rip, use ripgrep to search for the attribute 
equals:

```bash
rg 'buildRustPlatform ='
```

Which didn't work this time which is unfortunate

Julien Debon: Isn't it package?

Silvan: Oh `buildRustPackage`:

```bash
rg 'buildRustPackage ='
pkgs/development/compilers/rust/make-rust-platform.nix
15: ..
```

Oh awesome, I was gonna go for rustPlatform next but this makes it a bit easier:

```bash
vim pkgs/development/compilers/rust/make-rust-platform.nix
```

All right (searches for `/build`), `buildRustPackage` is this package down here. In vim useful `gf` to jump to file,
I guess most vim users already know that, but so this is the file, (`pkgs/build-support/rust/build-rust-package/default.nix`),
we have all the attributes here, we have `cargoVendorDir`, this isn't used, where is (`cargoSha256`), oh it's not in the
arguments up here. I don't like how this is done, how we have some arguments in here but also others are just accepted because
of the ellipsis here and apparently `cargoSha256` comes from there. Apparently, I'm not really sure why it's done this way,
but so `cargoSha256`, and this is used in the `cargoDeps` here, so this does `fetchCargoTarball` and it passes the
sha to that function, all right, so if we can override that function we could maybe do that:

```nix
  cargoDeps =
    if cargoVendorDir != null then null
    else if cargoLock != null then importCargoLock cargoLock
    else fetchCargoTarball ({
      inherit src srcs sourceRoot unpackPhase cargoUpdateHook;
      name = cargoDepsName;
      patches = cargoPatches;
    } // lib.optionalAttrs (args ? cargoHash) {
      hash = args.cargoHash;
    } // lib.optionalAttrs (args ? cargoSha256) {
      sha256 = args.cargoSha256;
    } // depsExtraArgs);
```

> This file currently looks like this:

```nix
cargoDeps' =
    if cargoVendorDir != null then
      null
    else if cargoDeps != null then
      cargoDeps
    else if cargoLock != null then
      importCargoLock cargoLock
    else if useFetchCargoVendor then
      fetchCargoVendor (
        {
          inherit
            src
            srcs
            sourceRoot
            cargoRoot
            preUnpack
            unpackPhase
            postUnpack
            ;
          name = cargoDepsName;
          patches = cargoPatches;
          hash = args.cargoHash;
        }
        // depsExtraArgs
      )
    else
      fetchCargoTarball (
        {
          inherit
            src
            srcs
            sourceRoot
            cargoRoot
            preUnpack
            unpackPhase
            postUnpack
            cargoUpdateHook
            ;
          name = cargoDepsName;
          patches = cargoPatches;
        }
        // lib.optionalAttrs (args ? cargoHash) {
          hash = args.cargoHash;
        }
        // lib.optionalAttrs (args ? cargoSha256) {
          sha256 = lib.warn "cargoSha256 is deprecated. Please use cargoHash with SRI hash instead" args.cargoSha256;
        }
        // depsExtraArgs
      );
```

But now, where does that `cargoDeps` get used? (`/cargoDeps`), let's grep for that. Okay, it get's passed in the
`mkDerivation`, in the final `mkDerivation` I believe:

> Current file:

```nix
# Tests don't currently work for `no_std`, and all custom sysroots are currently built without `std`.
# See https://os.phil-opp.com/testing/ for more information.
assert useSysroot -> !(args.doCheck or true);

stdenv.mkDerivation (
  (removeAttrs args [
    "depsExtraArgs"
    "cargoUpdateHook"
    "cargoDeps"
    "cargoLock"
  ])
  // lib.optionalAttrs useSysroot {
    RUSTFLAGS = "--sysroot ${sysroot} " + (args.RUSTFLAGS or "");
  }
  // lib.optionalAttrs (stdenv.hostPlatform.isDarwin && buildType == "debug") {
    RUSTFLAGS =
      "-C split-debuginfo=packed "
      + lib.optionalString useSysroot "--sysroot ${sysroot} "
      + (args.RUSTFLAGS or "");
  }
  // {
    cargoDeps = cargoDeps';
    inherit buildAndTestSubdir;
```

All right, so this sets all the flags, okay, so yeah I guess we can try this, I'm not sure if there is a better way to
do this. We're gonna take a look at this course afterwards, for now just from kind of a reverse engineering the code
I feel like we should first, so the `cargoDeps` here is passed in the `mkDerivation` so this is a derivation
attribute so we need to use `.overrideAttrs` to override `cargoDeps` and then on the `cargoDeps` we want to
override, we can use the old version and then call `.override` maybe?

Yuriy Taraday: `cargoDeps` is referred by some function, what it is?

Silvan: Yeah, `fetchCargoTarball`, it's another derivation:

```nix
else
    fetchCargoTarball (
      {
        inherit
          src
          srcs
```

Actually we need to take a look at the implementation of `fetchCargoTarball` as well to really figure it out.

Viktor Kleen: So I think I did that at some point in my NixOS flake and I did it exactly like you said it, 
did an overrideAttrs on the outer derivation and then inside and I said cargoDeps is derivation dot cargodeps dot
overrideAttrs and in that I said inherit the source and set the output hash to something.

Julien Debon: Yeah, we do exactly that in like the Nickel flake in case you're looking for an example.

Silvan: Okay, so that might also be the solution we're gonna find on discourse(?) then. Let me copy this into the..

Viktor Kleene: This solution is old, so maybe it improved since then but it still works.

Silvan: Maybe yeah. Well I cannot see looking at the buildRust or buildCargoPackage, I couldn't see any like 
improvement of that, maybe there is a PR as well, but yeah let's do the first step for now I guess, so we
wanna override `cargoDeps` here (`airshipper.nix`), `cargoDeps =`, then we're gonna use `old.cargoDeps` at the old
value, and then you said `old.cargoDeps.overrideAttrs` worked, well sure let me call it the same way, (`old: `),
actually let's not, sure:

```nix
cargoDeps = old.cargoDeps.overrideAttrs (old: {

});
```

And so in here you said `src`, I guess source you pass the same source as this one..

Viktor Kleene: I just said  `inherit src;` because we are doing a recursive record anyway

Silvan: Oh yeah, so we can do that here, nice, and then `outputHash =` I guess

Viktor Kleene: And that's what the new cargo hash sha256 would be.

Silvan: Yes, all right, so I guess I'm gonna pass empty for now to figure out the new one:

```nix
cargoDeps = old.cargoDeps.overrideAttrs (old: {
  inherit src;
  outputHash = "";
});
```

Let's try this:

```nix
self: super: {
  airshipper = super.airshipper.overrideAttrs (old: rec {
    version = "0.9.0";
    cargoDeps = old.cargoDeps.overrideAttrs (old: {
      inherit src;
      outputHash = "";
    });
    
    src = self.fetchFromGitLab {
        owner = "Veloren";
        repo = "airshipper";
        rev = "v${version}";
        hash = "sha256..";
    };
  });
}
```

This is the old one, let me also do this here:

```nix
nix-build -A airshipper --arg overlays '[ (import ./airshipper.nix) ]'
```

Okay, nice, and I'm waiting for a hash to be output, what?

Viktor Kleene: I think the name for the `cargoDeps` derivation is now messed up, or still the old one.

Silvan: Yeah, yeah, that's true. All right, it's doing the entire fetching of dependencies again right, so
thats taking a little bit of time.

Simonas Narbutas: But if you provide the hash, the correct hash, and it is in your store, then the name
as long as that directory that calculates to that hash is in your store, the name does not matter, right?

Silvan: Yeah, I think for fixed output derivation the, well, I think it actually does matter. Ideally it 
shouldn't matter, no, but I feel like since the nix store is used as the cache layer, if you change the name
the path is also going to change.

Simonas Narbutas: Yeah, I was playing with the name and I just kept not understanding why it's picking 
a new thing like, if I would provide a another hash from existing package in the store, but if I would
provide a fake hash then it would throw an error, but that's a little bit..

Viktor Kleene: Yeah, because the existing hash, because it's a fixed output derivation, if it knows
if the existing hash is already in the store it just takes it and it assumes it's all right, and if that's 
the wrong one..

Simonas Narbutas: And it knows that hash from a database from that sqlite database that it is in nix store or?

Viktor Kleene: I think so yeah.

Silvan: There is also, you shouldn't do this normally but you can use sqlite to just inspect the database itself
if you're curious. I don't recomment like actually:

```bash
sudo sqlite3 /nix/var/nix/db/db.sqlite
sqlite> .schema
```

We can actually just check out the schema here to see how this looks like and derivation outputs.. validPaths:

```bash
sqlite> .schema
CREATE TABLE ValidPaths (
    id               integer primary key autoincrement not null,
    path             text unique not null,
    hash             text not null, -- base16 representation
    registrationTime integer not null,
    deriver          text,
    narSize          integer,
    ultimate         integer, -- null implies "false"
    sigs             text, -- space-separated
    ca               text -- if not null, an assertion that the path is content-addressed; see ValidPathInfo
```

In here there is a hash, I'm not an expert in sqlite but if you're curious or want to do some interesting queries
on this or see how nix works underneath that's interesting. I guess meanwhile let's quickly check discourse.nixos.org
(searches for `cargoSha256`), I think these are mostly the same thing. Yeah, let's try this one 
https://discourse.nixos.org/t/is-it-possible-to-override-cargosha256-in-buildrustpackage/4393
Yeah, that does the same thing with output hash and source, we aren't overriding the name here, in the end the name
doesn't matter too much

Viktor Kleene: It's just a hygene thing, the name won't change the functionality

Silvan: Oh yeah, they are setting the name here, oh they are setting it with vendor which might be a good idea,
(`name = "${name}-vendor";`), all right, and we do have the hash back right here. So (`vim airshipper.nix`), over here,
(`outputHash = "...";`).

And so I feel like to just for completeness sake we also need to check out why `outputHash`, why not `hash` or `sha256`, 
why are there all these different names for hashes, and so this is really (`hashOutput`) kind of a nix implementation
detail, this is how nix code passes hashes to the nix store derivations, that wasn't great explanation, let me try again.
So let's do the import of nixpkgs in here:

```nix
nix-repl> import ./. { overlays = [ (import ./airshipper.nix) ]; }
```

Oh, and we don't want to evaluate all of nixpkgs, let's just do `:a` for adding the scope of this:

```nix
nix-repl> :a import ./. { overlays = [ (import ./airshipper.nix) ]; }
nix-repl> airshipper
nix-repl> airshipper.cargo
```

All right, so we have airshipper, we have cargoDeps here, (`airshipper.cargoDeps`), so this is the `cargoDeps` derivation
which apparently still has the 0.7.0 name and so here we can look at the attributes of the derivation that nix
uses underneath. They do exist on this level itself, and actually this is the same here `airshipper.cargoDeps` is
the derivation attribute that gets passed to it but you can also use if you want to be a bit clearer and not mess with
scopes too much, you can use `.drvAttrs`, then `cargoDeps`:

```nix
airshipper.drv
airshipper.drvAttrs.cargo
airshipper.drvAttrs.cargoDeps.drvAttrs.outputHash
```

And so here we have these three outputs, there is no output hash mode here, I guess there is a good default but 
these are the things nix passes to, nix uses underneath, so we have the output hash and `outputHashAlgo`, that's
`"sha256"`, I guess this also could be defaultet, inferred from this, and so yeah, there is no sha256 attribute here,
oh the completion doesn't work there, there is also no hash attribute here and so this is why when we use
`.overrideAttrs`, well we could set these attributes, like we could say:

```nix
nix-repl> airshipper.drvAttrs.cargoDeps.overrideAttrs (old: { Sha256 = "something"; })
```
This wouldn't actually influence the derivation because it's only gonna set an environment variable liket his to this value,
(`"sometething"`), it doesn't change the underlying output hash here that nix uses, (`...drv.Attrs.outputHash`).
So yeah, it's really not great this way I think that we need to do this outputHash thing, that's really, should
be an implementation detail but I guess that is the best way to do it for now. Yeah, just wanna quickly ask are there
any questions about the things we just talked about, or anything else here curious about or?

Simonas Narbutas: Many! No, no, no, I'm joking, it's a lot of information to take in but I'm pretty sure with this
I can already make those Rust package build derivaitions, and that was just one example, but I came across with that
two or three times, so that's gonna be very useful, thanks.

Silvan: Awesome, otherwise we can also if other people have other questions, could be related, could also be 
entirely something different, feel free to ask them. Otherwise if nobody has any question we could also take a 
issuse or PR's you might be interested in having merged or reviewed or taking a look at..

All right, well then we can also just kind of freeform something, and I'm gonna pick a random PR out of these.

Simonas Narbutas: Do you mind, like a very quick question, like in a nix repl, I wanted to pull out those,
like for example to find a hash, like how you did now import and then you knew how to navigate into drvAttrs
but is there a way to kind of print all of that what is under airshipper into some JSON format, like to spit it out.

Silvan: Maybe, let's, I guess let's try it out, so this is the old one:

```nix
nix-repl> airshipper
<<derivation /nix/store/bx..drv>>
```

Right, if you just print airshipper it's just gonna do the whole derivation thing here, I mentioned this in
the previous episode I believe, that you can override the type, the fact that it prints it in that kind of
odd way is only a nix repl thing, and it only gets triggered when the type is equal to the string derivation:

```nix
nix-repl> airshipper // { type = ""; }
```

If we don't have that, it's gonna do this (prints lots), this is rather messy but it kind of shows you the
underlying derivation value a bit better.

Simonas Narbutas: I should be able to find the sha that you listed in this output, I should be able to find it.

Silvan: Well there is the cargo sha here but the cargoDeps, can we find it.. right the cargoDeps is also just 
printed as the derivation value here and well we could, so we could use strict evaluation in the repl or
deeply evaluate the result here with `:p`:

```nix
nix-repl> airshipper // { type = ""; }
```

That would only expand these dot dots, so now it's just bigger value. Also sometimes this doesn't work because
you have things which only partially evaluate, well, actually no, because nix repl cuts off at the derivations
here that should actually always work. Yeah if you wanna go into these individually then we could do this again..

Simonas Narbutas: No, no, in the principle I get it, at least for me now it's clear, that answers my question, thanks.

Silvan: Awesome yeah, but you can also:

```nix
nix-repl> :p airshipper.drvAttrs
```

That doesn't need the weird type overriding thing and this has all the attributes that you can override with `.overrideAttrs`.
And so honestly this is quite useful, yeah I should recommend this more.

Simonas Narbutas: Yeah, thats actually.. thanks

Silvan: Yeah, I can also quickly mention or show you how derivation works underneath, so underneath this is really
the primitive nix uses:

```nix
nix-repl> `builtins.derivation {}`
error: attribute 'name' missing for call to 'derivationStrict'
```

And in here we can try calling this but we get a common error that name wasn't passed:

```nix
nix-repl> builtins.derivation { name = foo; }
error: required attribute 'builder' missing
```

Then we require a builder, let's use bin shell which is available in nix sandbox:

```nix
nix-repl> builtins.derivation { name = foo; builder = "/bin/sh"; }
error: required attribute 'system' missing
```

And then we also require a system, let's use the impure version here for now:

```nix
nix-repl> builtins.derivation { name = foo; builder = "bin/sh"; system = builtins.currentSystem; }
<<derivation /nix/store/9..-foo.drv>>
```

All right, and this is really the three basic components you need for a derivation and we can also
try building this:

```nix
nix-repl> :b builtins.derivation { name = foo; builder = "bin/sh"; system = builtins.currentSystem; }
error: builder for '/nix/store..-foo.drv' failed to produce output path for output 'out' at..
```

It will fail because we don't, it doesn't do actually do anything just yet, we can also provide
arguments to the builder command here, `-c` for passing the script, and let's just `touch` the
output directory so it succeedes:

```nix
nix-repl> builtins.derivation { name = foo; builder = "bin/sh"; args = [ "-c" "touch $out" ]; system = builtins.currentSystem; }
error: builder for .. failed with exit code 127;
```

Or not, let's do, I think this is, something that works in shell:

```nix
nix-repl> builtins.derivation { name = foo; builder = "bin/sh"; args = [ "-c" ">$out" ]; system = builtins.currentSystem; }
```

All right yeah, that works, so this we get the derivation out of here, let's sign this:

```nix
nix-repl> drv = builtins.derivation { name = foo; builder = "bin/sh"; args = [ "-c" ">$out" ]; system = builtins.currentSystem; }
nix-repl> drv
```

And this is again this derivation value here, we can also look at `drv.drvAttrs`:

```nix
nix-repl> drv.drvAttrs
{ args = [ ... ]; builder = "/bin/sh"; name = "foo"; system = "x86_64-linux"; }
```

These are the ones we passed to it directly, this is what the override with the `.overrideAttrs`, there is also
other attributes here, well in particular we have all of these attributes, the `args, `builder`, `name`, `system`,
we also have here:

```nix
nix-repl> drv.
drv.all     drv.builder    drv.drvPath    drv.out     drv.outputName    drv.type
drv.args    drv.drvAttrs   drv.name       drv.outPath drv.system
```

But there is also bunch of others, so we have `all`:

```nix
nix-repl> drv.all
[ <<derivation /nix/store..-foo.drv>> ]
```

That's not super useful but, actually I haven't seen any use of that in practice but it gets the all outputs of a
derivation in the list. We also have `outputName`:

```nix
nix-repl> drv.outputName
"out"
```

Which is the name of the output, which is the default is out, also useful for multiple outputs, it also sets
other outputs here if you have multiple of them, so I guess, the queue here and multiple outputs, let's say
outputs `out` and let's say `lib` and then let's change the script to do, also write to lib:

```nix
nix-repl> builtins.derivation { name = foo; builder = "bin/sh"; outputs = [ "out" "lib" ]; args = [ "-c" ">$out; >$lib" ]; system = builtins.currentSystem; }
```

Okay, now if we look at it again, we have `drv.out` for the output which is the default, we have `drv.lib` and then
also interesting we can do:

```nix
nix-repl> drv.out.out.out.lib.lib
```
And so on, it's kind of a recursive structure and so this is an extra things that the `builtins.derivation` does
to kind of make things more convenient but underneath there is also `derivationStrict` primitive:

```nix
nix-repl> derivationStrict
```

And this takes exactly the same arguments as the derivation primitive but it doesn't do this convenience thing on top.
So if I go back here and do `derivationStrict`:

```nix
nix-repl> builtins.derivationStrict { name = foo; builder = "bin/sh"; outputs = [ "out" "lib" ]; args = [ "-c" ">$out; >$lib" ]; system = builtins.currentSystem; }
```

Now, the result of this, `:p drv`, is really quite simple structure, we just have a derivation path and then one path for all 
of the outputs:

```nix
nix-repl> :p drv
{ drvPath = ".."; lib = ".."; out = ".."; }
```

Yeah, and that's it, everythin on top is something that the derivation primitive has, and we can even look at the 
implementation of derivation primitive. It's I believe, like one of the only components written in nix itself from
the builtins (`> 'derivation.nix`), (`> ./src/libexpr/primops/derivation.nix`), and this is how it's implemented,
this is the implementation of the 'derivation' builtin function, that just calls `derivationStrict` underneath and
otherwise is just like 27 lines of nix code and they do that the derivation thing here, they do the output name
we saw, they do the, the mapping of all the output names to attributes and so on. Just kind of a interesting behind
the scenes fact:

> Current file at: https://github.com/NixOS/nix/blob/442a2623e48357ff72c77bb11cf2cf06d94d2f90/src/libexpr/primops/derivation.nix#L4

```nix
# This is the implementation of the ‘derivation’ builtin function.
# It's actually a wrapper around the ‘derivationStrict’ primop.
# Note that the following comment will be shown in :doc in the repl, but not in the manual.

/**
  Create a derivation.

  # Inputs

  The single argument is an attribute set that describes what to build and how to build it.
  See https://nix.dev/manual/nix/2.23/language/derivations

  # Output

  The result is an attribute set that describes the derivation.
  Notably it contains the outputs, which in the context of the Nix language are special strings that refer to the output paths, which may not yet exist.
  The realisation of these outputs only occurs when needed; for example

    * When `nix-build` or a similar command is run, it realises the outputs that were requested on its command line.
      See https://nix.dev/manual/nix/2.23/command-ref/nix-build

    * When `import`, `readFile`, `readDir` or some other functions are called, they have to realise the outputs they depend on.
      This is referred to as "import from derivation".
      See https://nix.dev/manual/nix/2.23/language/import-from-derivation

  Note that `derivation` is very bare-bones, and provides almost no commands during the build.
  Most likely, you'll want to use functions like `stdenv.mkDerivation` in Nixpkgs to set up a basic environment.
*/
drvAttrs @ { outputs ? [ "out" ], ... }:

let

  strict = derivationStrict drvAttrs;

  commonAttrs = drvAttrs // (builtins.listToAttrs outputsList) //
    { all = map (x: x.value) outputsList;
      inherit drvAttrs;
    };

  outputToAttrListElement = outputName:
    { name = outputName;
      value = commonAttrs // {
        outPath = builtins.getAttr outputName strict;
        drvPath = strict.drvPath;
        type = "derivation";
        inherit outputName;
      };
    };

  outputsList = map outputToAttrListElement outputs;

in (builtins.head outputsList).value
```

Yuriy Taraday: Can you build the result of the `derivationStrict`?

Silvan: Yeah, let's try this again, so I'm not sure if nix-repl allows us to build it:

```nix
nix-repl> :b drv.out
error: expression does not evaluate to a derivation, so I can't build it
```

But we can evaluate this:

```nix
nix-repl> out
error: undefined variable 'out'
```

```nix
nix-repl> drv.out
"/nix/store..-foo"
```

So yeah, nix repl really expects this type equals derivation thing:

```nix
nix-repl> { type = "derivation"; }
<<derivation ???>>
```

Then it works with that.

Julien Debon: So if we add type then it will build?

Silvan: Ok, it goes a bit further than that, nix repl doesn't just need the type, let's try,
then try to build it:

```nix
nix-repl> drv // { type = "derivation"; }
<<derivation /nix/store..-foo.drv>>

nix-repl> :b drv // { type = "derivation" ; }
error: derivation name missing
```

Okay, it also apparently wants a derivation name to be known so let's try it here:

```nix
nix-repl> :b drv // { name = "foo"; type = "derivation" ; }

This derivation produced the following outputs:
  lib -> /nix/store..-foo-lib
  out -> /nix/store..-foo
```

Oh, that worked actually. Interesting. I am a bit surprised:

```nix
{ drvPath = "/nix/store..foo.drv"; lib = "/nix/store..foo-lib"; out = "/nix/store..foo"; }
```

Okay, I guess it uses drvPath, that does exist, so, yeah, I guess nix repl needs type equals derivation, and then it needs name
and it needs the drvPath.

Yuriy Taraday: Although in this drvPath we have more right?

Silvan: More what?

Yuriy Taraday: I mean in the derivation itself we have more information if it can build it because right now drv is just
like three fields but the derivation itself should have like builder..

Silvan: Oh yeah, yeah, so I guess, yeah, that's interesting, if we look at like the hello, just another derivation that kind of
looks normal, let's look at the things it contains:

```nix
❯ nix repl
Nix 2.24.11
Type :? for help.
nix-repl> :l <nixpkgs>
Added 23384 variables.

nix-repl> hello
«derivation /nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv»

nix-repl> hello // { type = ""; }
{
  __ignoreNulls = true;
  __structuredAttrs = false;
  all = [ ... ];
  args = [ ... ];
  buildInputs = [ ... ];
  builder = "/nix/store/5mh7kaj2fyv8mk4sfq1brwxgc02884wi-bash-5.2p37/bin/bash";
  cmakeFlags = [ ... ];
  configureFlags = [ ... ];
  depsBuildBuild = [ ... ];
  depsBuildBuildPropagated = [ ... ];
  depsBuildTarget = [ ... ];
  depsBuildTargetPropagated = [ ... ];
  depsHostHost = [ ... ];
  depsHostHostPropagated = [ ... ];
  depsTargetTarget = [ ... ];
  depsTargetTargetPropagated = [ ... ];
  doCheck = true;
  doInstallCheck = true;
  drvAttrs = { ... };
  drvPath = "/nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv";
  inputDerivation = «derivation /nix/store/zzs21qyzilwbd4z02b4pbs3bvdz2rgdv-hello-2.12.1.drv»;
  mesonFlags = [ ... ];
  meta = { ... };
  name = "hello-2.12.1";
  nativeBuildInputs = [ ... ];
  out = «derivation /nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv»;
  outPath = "/nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1";
  outputName = "out";
  outputs = [ ... ];
  override = { ... };
  overrideAttrs = «lambda overrideAttrs @ /nix/store/x6sw6hx2yrnvj1hiixaj5gcvxbsjpbcx-nixos/nixos/lib/customisation.nix:177:13»;
  overrideDerivation = «lambda overrideDerivation @ /nix/store/x6sw6hx2yrnvj1hiixaj5gcvxbsjpbcx-nixos/nixos/lib/customisation.nix:175:32»;
  passthru = { ... };
  patches = [ ... ];
  pname = "hello";
  postInstallCheck = "stat \"\${!outputBin}/bin/hello\"\n";
  propagatedBuildInputs = [ ... ];
  propagatedNativeBuildInputs = [ ... ];
  src = «derivation /nix/store/q63c1b6gh3i7vjw2bsvxwbbcwcnmxxk1-hello-2.12.1.tar.gz.drv»;
  stdenv = «derivation /nix/store/asnfc1fbhcpnrhnk4kkrs5zrb5gdf5qs-stdenv-linux.drv»;
  strictDeps = false;
  system = "x86_64-linux";
  tests = { ... };
  type = "";
  userHook = null;
  version = "2.12.1";
}
```

So well, all of these attributes do describe how to do the build but these are only really added for the nix evaluations
so you can use these attributes for your nix code, so you can access like, I mean, `meta = { ... }` is important, a lot of 
these are very important, like `propagatedBuildInputs`, or you might access it for debugging, I guess that's nice but otherwise
they aren't used for anything and they're essentially thrown away if you don't access them. The thing that underneath stores
 the build recipe is this path here, and it's actually when you do `derivationStrict` not only does it compute these paths and
return it, it also writes to this path (`drvPath`), it doesn't write to these paths, (`lib`, `out`), derivation computation
only writes to this one and so if you look at this one now (`drvPath`), let's do `cat /nix/store..foo.drv`) we can see in here
that's the, the format of derivation files, they have kind of a, I think it's a python-like format which nix reads, so here 
we have the outputs that we have, we have lib output, and the output, we have the system, builder, arguments and so on and 
then all the environment variables down here.

Julian Debon: So it means that derivation and derivationStrict are not pure, right? They write to the store.

Silvan: Yeah you can say that yes.. it's.. I wouldn't say they're like actually pure, it's more of an implementation detail to
how it's done that might actually change in the future.

Yuriy Taraday: Is that because every derivation is content addressable? It's just caching, it's not impurity I guess. Right? 
So you will not write anything different to the same store path of a derivation, anything else about the content that it got.

Silvan: Yeah, it does really have the side effect of writing something to the store during the evaluation which is a bit impure
but in practice it's not a problem. Yeah, and I just wanted to mention there's `nix show-derivation` which shows you this
in a JSON which is nice. 

Q: Is there a reason why the JSON format was not chosen for the derivation file itself?

Silvan: I think probably because this format is like 20 years old, that might be the reason yeah

Yuriy Taraday: But also JSON is not the best format, so probably it was expected to have as simple to parse and as strict
format as possible.

Silvan: Yeah, okay, I feel like nowadays JSON might be an acceptable candidate but yeah, there's also other formats that
could be chosen. I think this is nice that still it's a string and not like a binary format but honestly you have to
show derivation so you don't really need to look at this.

Yeah, something else I can show in here, in this case, this derivation doesn't have any inputs, well there's two
kinds of inputs, derivations (`"inputDrvs": {},`), and sources (`"inputSrc": [],`), sources are just files, and
derivations are actual other derivations. If we look at the hello derivation.

Let's do `nix-instantiate` to just evaluate some nix code and return the derivation and let's just do hello here:

```nix
❯ nix-instantiate '<nixpkgs>' -A hello
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
```

Then `nix show-derivation` on that:

```nix
❯ nix show-derivation /nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
warning: 'show-derivation' is a deprecated alias for 'derivation show'
{
  "/nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv": {
    "args": [
      "-e",
      "/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh"
    ],
    "builder": "/nix/store/5mh7kaj2fyv8mk4sfq1brwxgc02884wi-bash-5.2p37/bin/bash",
    "env": {
      "__structuredAttrs": "",
      "buildInputs": "",
      "builder": "/nix/store/5mh7kaj2fyv8mk4sfq1brwxgc02884wi-bash-5.2p37/bin/bash",
      "cmakeFlags": "",
      "configureFlags": "",
      "depsBuildBuild": "",
      "depsBuildBuildPropagated": "",
      "depsBuildTarget": "",
      "depsBuildTargetPropagated": "",
      "depsHostHost": "",
      "depsHostHostPropagated": "",
      "depsTargetTarget": "",
      "depsTargetTargetPropagated": "",
      "doCheck": "1",
      "doInstallCheck": "1",
      "mesonFlags": "",
      "name": "hello-2.12.1",
      "nativeBuildInputs": "/nix/store/096i6ysqh596z1srsh758z3swz00kmlr-version-check-hook",
      "out": "/nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1",
      "outputs": "out",
      "patches": "",
      "pname": "hello",
      "postInstallCheck": "stat \"${!outputBin}/bin/hello\"\n",
      "propagatedBuildInputs": "",
      "propagatedNativeBuildInputs": "",
      "src": "/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz",
      "stdenv": "/nix/store/d0gfdcag8bxzvg7ww4s7px4lf8sxisyx-stdenv-linux",
      "strictDeps": "",
      "system": "x86_64-linux",
      "version": "2.12.1"
    },
    "inputDrvs": {
      "/nix/store/asnfc1fbhcpnrhnk4kkrs5zrb5gdf5qs-stdenv-linux.drv": {
        "dynamicOutputs": {},
        "outputs": [
          "out"
        ]
      },
      "/nix/store/jyw76friy6pgv3rqvf78lqj8fy9krvz1-version-check-hook.drv": {
        "dynamicOutputs": {},
        "outputs": [
          "out"
        ]
      },
      "/nix/store/q63c1b6gh3i7vjw2bsvxwbbcwcnmxxk1-hello-2.12.1.tar.gz.drv": {
        "dynamicOutputs": {},
        "outputs": [
          "out"
        ]
      },
      "/nix/store/vrx8z3fnwbcfggqhjmj1hz4szfw59fwh-bash-5.2p37.drv": {
        "dynamicOutputs": {},
        "outputs": [
          "out"
        ]
      }
    },
    "inputSrcs": [
      "/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh"
    ],
    "name": "hello-2.12.1",
    "outputs": {
      "out": {
        "path": "/nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1"
      }
    },
    "system": "x86_64-linux"
  }
}
```

Okay, in here we can see there is input sources,(`"inputSrcs"`), this is just a default builder, I think that's, well let's
take a look at that, what is that:

```nix
nvim /nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh
```

```sh
if [ -e "$NIX_ATTRS_SH_FILE" ]; then . "$NIX_ATTRS_SH_FILE"; elif [ -f .attrs.sh ]; then . .attrs.sh; fi

source $stdenv/setup
genericBuild
```

Oh, that just calls `genericBuild` so this is the standard env builder which does all the phases and stuff. And `inputDrvs` in here
we have the `stdenv`, we have the `hello` source, and we have the bash, and so this is something these derivations track, this
is a bit inconvenient to work with, just looking at the `inputDrvs` here, so can also use nix store for that:

```nix
nix-store --query
```

`nix-store --queary` allows you to get all this information in a command. So here there is bunch of useful flags:

```nix
❯ nix-store --query --
--binding            -- Print the value of an attribute of the store derivations
--deriver            -- Print the deriver of the store paths
--force-realise      -- Realise each argument to the query first
--graph              -- Print the references graph of the store paths in Graphviz format
--hash               -- Print the SHA-256 hash of the contents of the store paths
--outputs            -- Print the output paths of the given store derivations
--references         -- Print immediate dependencies of the given store paths
--referrers-closure  -- Print the closure under the referrers relation
--referrers          -- Print store paths which refer to these paths
--requisites         -- Print the closure of the given store paths
--roots              -- Print the garbage collector roots that point to the store paths
--size               -- Print the size in bytes of the contents of the store paths
--tree               -- Print the references graph of the store paths as an ASCII tree
--use-output         -- Apply the query to the output path of any store derivations
```

Immediate dependencies, I think this is essentially the `inputDrvs` so let's print this:

```nix
nix-store --query --references
```

of hash.. here:

```nix
❯ nix-store --query --references /nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh
/nix/store/vrx8z3fnwbcfggqhjmj1hz4szfw59fwh-bash-5.2p37.drv
/nix/store/asnfc1fbhcpnrhnk4kkrs5zrb5gdf5qs-stdenv-linux.drv
/nix/store/jyw76friy6pgv3rqvf78lqj8fy9krvz1-version-check-hook.drv
/nix/store/q63c1b6gh3i7vjw2bsvxwbbcwcnmxxk1-hello-2.12.1.tar.gz.drv
```

Yeah, okay, and here we get these four paths we've seen earlier and we can also get the closure of this,
so all the files, all the derivations that these also depend on and recursively set, this would be
`--requisites`, yes:

```nix
❯ nix-store --query --requisites /nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
/nix/store/001gp43bjqzx60cg345n2slzg7131za8-nix-nss-open-files.patch
/nix/store/026i5h3a3pg28dxgv1x90117z6diha3x-byacc-20240109.tgz.drv
/nix/store/0m4y3j4pnivlhhpr5yqdvlly86p93fwc-busybox.drv
/nix/store/i9nx0dp1khrgikqr95ryy2jkigr4c5yv-unpack-bootstrap-tools.sh
/nix/store/xjkydxc0n24mwxp8kh4wn5jq0fppga9k-bootstrap-tools.tar.xz.drv
/nix/store/05q48dcd4lgk4vh7wyk330gr2fr082i2-bootstrap-tools.drv
... # (366 lines)
```

So this is a whole bunch of things, the dependency chain goes quite deep, so we have like 300 dependencies about,
there's also other flags here which can go the other way, we have `--referrers`, this tells you which other paths
reference this one, refers closure, the closure of that, there's also short flags to some of these, that's nice,
and also gc `--roots`, `--hash`, I haven't used all of these actually, `--deriver` is also actually kind of useful,
so let's say we were to build a derivation, so we'll nix instantiate, evaluates to derivation:

```nix
❯ nix-instantiate '<nixpkgs>' -A hello
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
```

We can then build this derivation path with `nix-store --realise`:

```nix
❯ nix-store --realise /nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
this path will be fetched (0.05 MiB download, 0.22 MiB unpacked):
  /nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1
copying path '/nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1' from 'https://cache.nixos.org'...
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1
```

Well this time it was already cached locally but it could substitute it or build it locally if it didn't exist yet.
But now let's say we have this path and we don't know which derivation produced it, now we can use:

```nix
❯ nix-store --query --deriver /nix/store/a7hnr9dcmx3qkkn8a20g7md1wya5zc9l-hello-2.12.1
/nix/store/pznj731mjim1xdd5mir97l20pk3gy5a8-hello-2.12.1.drv
```

This gives us back the `drv` path, this doesn't always work though, let's see for example, let's fetch the latest
master version here:

```sh
git pull
```

```sh
git pull origin master
```

I just want to have a derivation that's built in hydra but not locally, so let's see, let's do:

```nix
nix-instantiate '<nixpkgs>' -A hello
nix-instantiate -A hello
```

So this derivation, let's see 48.32
