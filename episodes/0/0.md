All right, well let's start super basically, I'm gonna use vim and editing the `default.nix` file:

```
vim default.nix
```
That's the file nix evaluates by default, so let's open the file and some super basic nix stuff, 
let's just do like a null, simplest value:

```nix
null
```

And then I can evaluate this, using, so there's an old way to evaluate things and a new way to evaluate things, the
old way to just evaluate the nix values is kind of convoluted, it's `nix-instantiate --eval`, ideally it should just
be `nix-eval` but legacy, `nix-instantiate --eval` and that should be it.

```nix
> nix-instantiate --eval 
null
```

Yes, so it evaluated `null`.
That's the `default.nix` file, we can also pass the file name explicitly:

```nix
nix-instantiate --eval default.nix
null
```
And that also works. Generally you don't have to use `nix-instantiate --eval` because in here you 
have like a derivation or something, generally with nix you wanna build derivations instead of just 
evaluating nix itself, but yeah, let's start with evaluation for now. 

So you have simple values, one of the main data structures in nix is the attribute set, lets add names here:

```nix
# Attribute set
{

}
```

That's just a dictionary known from almost every language out there you can have keys and values:

```nix
# Attribute set
{
  foo = null;
}
```
Keys don't have to be quoted like json, there is an equal sign and a semicolon at the end. You can quote keys
as well, `"foo" = values;`, that isn't needed when you have special symbols in here for example like a dot,
`"foo.bar"` so we can evaluate this:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;
}
```

```nix
:!nix-instantiate --eval default.nix
{ foo = null; "foo.bar" = null; }
```

This evaluates to just what you see, but if we were to use this literally like this:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
}
```


this would nested in another set, so this is, what is it, `# syntactic sugar for:` foo equals 
another attribute set:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
    # syntactic sugar for:
    foo = {
      bar = null;
    };
}
```

So it just nests it automatically for you, let's quote this out for now so that we don't get like conflict:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    foo.bar = null;
    # syntactic sugar for:
    # foo = {
    #   bar = null;
    # };
}
```

```nix
❯ nix-instantiate --eval default.nix
error: attribute 'foo.bar' already defined at /home/stablejoy/code/nix-hour-transcripts/episodes/0/default.nix:3:5
       at /home/stablejoy/code/nix-hour-transcripts/episodes/0/default.nix:6:5:
            5|
            6|     foo.bar = null;
             |     ^
            7|     # syntactic sugar for:
 ~/code/nix-hour-transcripts/episodes/0  main ?1
```

Oh I declared `foo` here already, so maybe that's good to see:

```nix
:!nix-instantiate --eval default.nix
error: attribute 'foo.bar' already defined at /home/infinisil/test/nix-tutorial/default.nix:3:3..
```

Foo.. OK, that's an error in nix, geez. It's starting out well (smiles). So apparently it says `foo.bar` is already defined,
but then it points to, wait..

Matthew Healy: Is it because of the string one at line 4 or?

Silvan: I don't think it should be those, it should be different, I can come to that and see, yeah now, so apparently,
that is really conflict because if we syntacticly desugar this, I guess it does make sense, you have one foo null,
and one for the attribute set, all right, so I think it was just like an error in the error message but yeah it's 
conflict, you can only define an attribute once and so that is sometimes a bit tricky to see, sometimes you have 
like a big nix file and you do like `foo.bar` somewhere and then at a later time something else with `foo =`, but
yeah, let's continue on.

We can, some other values, integers, we also can do operations with integers like addition, `int = 10 + 10;`,
division, `int = 10 + 2 / 3`, subtraction, `int = 10 + 2 / 3 - 10;`. Integer division (`/`), is like, it doesn't use
floats, this (`2 / 3`) would get zero here. And here we are coming into lazy evaluation for the first time:

```nix
# Attribute set
{
    foo = null;
    "foo.bar" = null;

    fooz.bar = null;

    int = 10 + 2 / 3 - 10;
}
```

```nix
:!nix-instantiate --eval default.nix
{ foo = null; "foo.bar" = null; fooz = <CODE>; int = <CODE>; }
```

So if we just do the `nix-instantiate --eval` it shows like a `<CODE>` here which means that it hasn't evaluated this
fully. This is a bit of a detail to how it is implemented but we can just add a `--strict` here `nix-instantiate --eval --strict`
to force it to evaluate the whole thing, so then you can see the full values here:

```nix
:!nix-instantiate --eval --strict
{ foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

There is also floats, floats aren't often used, `floats = 10 + 2 / 3 - 10;` 
but if you just add a, like a dot, `10.0`, like it converts the whole
expression to a floating thing:

```nix
:!nix-instantiate --eval --strict
{ floats = 0; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

Or, this part, `2.0`, I think you need here as well, like if there is at least one floating operation in the
pipeline it turns it into a float:

```nix
:!nix-instantiate --eval --strict 
{ floats = 0.666667; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; }
```

All right, there is a weird thing going on where it only prints the first six digits, `0.666667`, which is
often times a bit inaqurate, but, something to fix in nix. Then some other, what do we have, we have
floats, we have strings of course:

```nix
str = "foo bar";
```

Then strings can have interpolation. Certainly we need variables for this group so let's look at variables.
So variables, we can do a let in statement to declare variables so we can say, let `someVariable = 10;` 
in then the expression we want to evaluate with that variable in scope and we can say
`someVariable + 1;`

```nix
variables = 
  let someVariable = 10;
  in someVariable + 1;
```

Let's evaluate this:

```nix
:!nix-instantiate --eval --strict
{ floats = 0.666667; foo = null; "foo.bar" = null; fooz = { bar = null; }; int = 0; str = "foo bar";
variables = 11; }
```

It works. Let's get down a bit here. So with variables we can then also use interpolation. We'd say let
`someVariable = 10` or we need generally a, actually you don't need variables for interpolation I'm just
realizing but let's use like this for now so we can have some string, or let's say `someName = Silvan`,
in `"Hello, ${someName}";`:

```nix
interpolation = 
  let someName = "Silvan";
  in "Hello, ${someName}";
```

So this is how interpolation looks like in nix, the dollar, curly brackets, then in here, `{}`, you can
also do, like this is a general nix expression, you can put anything here, you can also add like a plus,
`{someName + }`, by the way plus is also for string concatenation, Silvan, let's add my last name here,
`${someName + " Mosberger"}";`, so you can do this, the quotes do get a bit confusing here, but the
string addition here, this is the same as just, moving Mosberger out here like this:

```nix
interpolation = 
  let someName = "Silvan";
  in "Hello, ${ someName + " Mosberger" }";
  
interpolation' = 
  let someName = "Silvan";
  in "Hello, ${ someName } Mosberger";
```

Of course, we can do then more complicated operations in here, that's any nix expression, so we can do like
`let a = 10`, and then multiple variables, just add more of them, oh you need a semicolon, `let a = 10;`,
`b = 20;`, then we can do something like, `${ a + b }`, now this will throw an error because string interpolation
needs a string so if we were to evaluate this:

```nix
interpolation'' =
  let 
    a = 10;
    b = 20;
  in "Hello, ${a + b}";
```

```nix
:!nix-instantiate --eval --strict
error: cannot coerce an integer to a string
...
```

Yeah, so this says cannot coerce an integer to a string, makes sense, we, there are builtin functions in nix
which we can call from anywhere so one of these functions is `toString`, this converts pretty much anything
to a string with some weird behaviour as well, `${ toString (a + b) }";`, parenthesis to make sure it doesn't 
just convert the first one and then this should work, (returns `interpolation'' = "Hello, 30";`), right
so `toString` useful builtin function. 

There is some, like let's use `toStringExample = toString false;`, so this is some weird behaviour,
to string of false, oh actually let's do, it's kind of hard to see the output here, (returns `toStringExample = "";`)
but if we look at this, it turns into the empty string, and that comes from bash, like yeah, makes it simple to
have that work for bash:

```nix
toStringExample = toString false;
  -- returns toStringExample = "";
toStringExample = toString true;
  -- returns toStringExample = 1;
```

Empty string and one. Yeah, but it's, it works for integers, but it also works for other things but let's get
to that later. Then what other basic things do we have. Right of course, we have attribute access or 
`attributeSelectors = ` is maybe the right way, the right word, so let's say we define some attribute set here,
let's say call it `foo = `, we can also use the dot syntax here, `foo.bar`, so `foo.bar.baz = 10;`, let's also do
like `foo.bar.qux = 20;`, right, internally nix combines these into single ones so this should be valid, and so
then we can also access the attributes of course so we can say access `in foo.bar.baz`, that's how you access
these attributes again. So this just evaluates to 10.

```nix
attributeSelectors = 
  let
    foo.bar.baz = 10;
    foo.bar.qux = 20;
  in foo.bar.baz;
```

Let's actually do like this, that's kind of easier to see:

```nix
attributeSelectors = 
  let
    foo = {
      bar.baz = 10;
      bar.qux = 20;
    };
  in foo.bar.baz;
```

All right, so this works. We can also do defaulting, `attributeSelectorsDefaulting`, where, let's say we access,
we try to access an attribute that doesn't exist `foo.bar.baz.hello`, now if we try to evaluate this we get,
`error: attribute 'hello' missing`, and so what we can do as a fallback is to you the `or` operator and we can say
`or 30`. This means that if this attribute doesn't exist just return 30.

```nix
attributeSelectorsDefaulting =
  let
    foo = {
      bar.baz = 10;
      bar.qux = 20;
    };
  in foo.bar.baz.hello or 30;
```

If we do this, we get 30 here, `attributeSelectorsDefaulting = 30;`. That also works kind of nested, that
almost works for anything actually so you could say `in foo.bar.hello.foo.bar or 30;`, that also works. Yes,
all right. That is a common gotcha because the `or` isn't the binary `or` operator, those two exist.

Let's do like `booleanOps = (true && false) || (true -> false);`, and this one we have implication `true -> false`,
and the implication is really just if the left one is true then the right one needs to be true as well, but can be
desugared to the, to this I believe `(!true || false);`, yeah it's sometimes useful. Are there any other? Oh there
is `not` of course, a exclamation mark is not, `!`, `(true && ! false)`, all right so we have that, let's see 
what would be next. We have string interpolation, we have this, variables.. functions I guess would be good next step.

So you declare functions with a colon, `someFun = x:`, so declare the name of the function argument, then a colon, and then
let's say, let's do return `x + 1;`, `x: x + 1;`, so that's like, in python it would be, do I know python? 
`def someFun(x): return x + 1..` Matthew H.: Looks good, I don't know python. 

```nix
someFun = x: x + 1;
```

And then if you want to take multiple arguments you just kind of, well one of the ways you can do it is to just to do like this,
`someFun' = x: y: x + y;`, kind of just take an argument, `x`, return a function `(y: x + y)` so this is just this, and then
you use currying to apply this so let's do like:

```nix
someFun = 
  let f = x: x + 1;
  in f 1;

someFun' =
  let f = x: y: x + y;
  in f 1 2;
```

So this, are you somewhat familiar with functional programming?

Matthew H: Yeah.

Silvan: From Haskell maybe?

Matthew H: More from Scala, but I know a bit of Haskell.

Silvan: Nice, so do you know about currying already

Matthew H.: Yes, yeah.

Silvan: Nice, nice.

Yes, so this is one way to apply multiple arguments. Another is to, arguments can be, you can take an attribute set or
destructure an attribute set as an argument so let's do `someAttrs = let f = {`, so the way you can do this is by kind
of taking an attribute set here so let's say we have `{ x, y }: x + y; in` and so this is a function that takes an attribute 
set with exactly the attributes `x` and `y` in it so this way we can do `x = 2;`, `y = 3;` and this is generally the
recommended way to declare functions because you could name arguments this way:

```nix
someFunAttrs = 
  let f = { x, y }: x + y;
  in f {
    x = 2;
    y = 3;
  };
```

And, also it's easy to add additional arguments later in a way that it doesn't brake all the code because if you were
to add the next one here `let f = x: y: z: x + y; in f 1 2;` it would just brake this and return a function whereas if
you add one here, `let f = { x, y, z }:` you get an error where `z` isn't provided.

Now these function arguments have some other capabilities, something else is you can take an elipsis, it's what it's called.
This allows you to take and ignore arbitrary other arguments, `f = {x, y, ...}:` so you could do this, how should we do this:

```nix
someFunAttrs' =
  let
    f = { x, y, ... }: x + y;
  in f {
    x = 2;
    y = 3;
    ignored = 4;
  };
```

Matthew H: If you don't have the elipsis does that mean it will only accept an attribute set with exactly `x` and `y` or?

Silvan: Exactly, yeah, if you don't provide one it will get an error, and if you provide something else it will also provide
an error. 

Matthew: OK

Silvan: Yep, right, you can also not provide one that's given here if you have a default here, this can be done with a 
question mark, `f = { x ? , y, ... }:`, so you can do like, let's give `x` a default of `1`, that's again an arbitrary nix
expression here, `f = { x ? 1, y, ... }: x + y;`, so default of `1`, and then we don't have to pass this, `x = 2`:

```nix
someFunAttrs' =
  let
    f = { x ? 1, y, ... }: x + y;
  in
    -- x = 2;
    y = 3;
    ignored = 4;
  };
```

There is some arguments against, so these defaults don't work super well sometimes, there's other ways to do this better sometimes,
let's go over this for now. So what you can also do is capture the entire attribute set that's passed here, kind of, let's say you
had something like:

```nix
someFunAttrs'' = 
  let
    f = { x ? 1, y, ... }: x + y;
    g = attrs: attrs.x + attrs.y
...
```

Oh yeah, we can like make a whole combination here so these are almost equivalent:

```nix
someFunAttrs'' =
  let
    f = { x ? 1, y, ... }: x + y;
    g = attrs: attrs.x or 1 + attrs.y
```

So the first one (`f`), explicitly destructures the attribute set, defaults `x` to `1`, `x ? 1`, then adds them, `x + y;`, and this here,
`attrs.x` accesses `x` and uses the `or` opeartor to default it to `1` and also accesses `y`, `attrs.y`, so that's a good example.
There is one slight difference where kind of destructuring of the attribute set here happens before the function even starts
evaluating, `f = { x ? 1, y, ... }:`, whereas here it doesn't happen before, `g = attrs:`, like this is just a variable, it 
doesn't get evaluated if you don't, without this. But you can also somehow combine these a bit, and that's like, let's do like,
by giving, using `attrs@`, actually that also works the other way around, this also works:

```nix
fg = attrs@{ x ? 1, y, ...}: x + y;
gf = { x ? 1, y, ... }@attrs: x + y;
```

And then you can, both get this destructuring here and you can catch kind of the attrs itself, and so this way you can,
you can do this for example `x + attrs.y`, or let's do `x + y + attrs.notIgnored;`, so that works.

Let's go to like if expression as well quick, so very basic `if true then false else true;`:

```nix
ifExpr = if true then false else true;
```

Or:

```nix
ifExpr = if 1 + 1 == 2 then "Yes" else "No";
```

And you can provide different types here as well, `else 10;`.

Matthew H.: Does the condition have to be a boolean, or is, could it be like, are the other values..

Silvan: Yes, it has to be a boolean, anything else doesn't work. Yes and so, we can also kind of combine. Sorry let's make like a,
let's say we have a function `functionMaybeArgument` where we do something like, so we declare a function, `let f = ` and we say
the function takes like an x, `{ x, `, a y, `{ x, y }`, and attrs, `{ x, y }@attrs:`, and let's do like, `attrs@: x`, well
that's also an ellipsis, `{ x, y, ...}@attrs:`, so we can get other arguments, so like `x + y +` and let's do like an
`if attrs`, oh yeah, we haven't, okay we need to first talk about something else here:

```nix
# functionMaybeArgument =
#  let f = { x, y, ... }@attrs: x + y + if attrs
```

So we can check for attributes, `checkForAttributes = `, we can do something like this, `let foo.bar.baz = 10;`, and then we can check
whether it contains a certain attribute without having to access or evaluate it, `in foo ?`, that's with the question mark operator,
so we can ask, `in foo ? bar`, does this contain `bar`? And this also works with full paths, `bar.baz`, so we can say does this contain
`bar`, and does `bar` contain `baz`? And so in this case this would evaluate to true. This, `in foo ? bar.foo;` would evaluate to false,
and so on:

```nix
checkForAttributes =
  let foo.bar.baz = 10;
  in foo ? bar.baz;
```

And so this way in here we can check whether `attrs ?` contains like `notIgnored`, or `maybeIgnored`, or actually `notIgnored`,
so we check whether it contains a `notIgnored`, if it does contain that, `then`, let's go to new line here, ok formatting is a
bit messy, if attrs contains one of these attributes then we can say, let's also add `attrs.notIgnored else 0;`, in
`f { x = 1; y = 2; notIgnored = 3; };`, yeah so that works:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }attrs@:
      x + y + if attrs ? notIgnored then attrs.notIgnored else 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

And I'm just realizing that that's actually the same as this, as `attrs.notIgnored or 0`:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }@attrs:
      x + y + if attrs ? notIgnored then attrs.notIgnored else 0;
    f = { x, y, ... }@attrs:
      x + y + attrs.notIgnored or 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

I'm not sure about the precedence here actually (`.. + if ..`), let's try to evaluate this, maybe it will fail:

```nix
:!nix-instantiate --eval --strict
error: syntax error, unexpected IF ..
```

Yep, that does fail, so we need a parenthesis here:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }@attrs:
      x + y + (if attrs ? notIgnored then attrs.notIgnored else 0);
    f = { x, y, ... }@attrs:
      x + y + attrs.notIgnored or 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

```nix
:!nix-instantiate --eval --strict
error: attribute 'f' already defined..
```

Oh, and `f`'s already defined:

```nix
functionMaybeArgument =
  let 
    f = { x, y, ... }@attrs:
      x + y + (if attrs ? notIgnored then attrs.notIgnored else 0);
    f' = { x, y, ... }@attrs:
      x + y + attrs.notIgnored or 0;
  in f { x = 1; y = 2; notIgnored = 3; };
```

Okay, we have evaluation working again. Yes so that's mainly functions. Something to point out here, it's a bit of a quirk
in nix is that `functionDefaultsQuirk = let f`, let's say you have a, well it goes a bit too deep maybe already, but let's
say you have some defaulting argument here, `let f = { x ? 10 }`, and then you do like `@attrs:`, and then you try to check
whether attrs contains x, `attrs ? x;`, now what's, `in`, it's kind of a interesting question what, or let's also do like,
`in f {}`, so attrs here, `(@attrs:)`, doesn't do anything regarding like these defaults, `{ x ? 10 }`, attrs is literally
just the thing you pass in, `f {}`, and so if you don't pass an x here, `{ x ? 10 }`, even though you can like use this 
`x` variable here, `x attrs ?`, the check here will fail, it won't contain an `x`, let's evaluate this:

```nix
functionDefaultsQuirk = 
  let f = { x ? 10 }@attrs: attrs ? x;
  in f {};
```

```nix
:!nix-instantiate --eval --strict
..functionDefaultsQuirk = false;
```

Yeah, it's false, yeah and so that's a bit of a catch. 

Yeah and, maybe we can look at some builtin functions. `builtinsFuns = `, so there is, we have functions like, so pretty much
all of these are accessible under `builtins.`, that's kind of the builtins operator, also `builtins.toString;` is here, we have,
oh lists, we haven't checked out lists, I'm just realizing, but yeah, lists are just the normal thing, but something to point out
is that elements are separated by spaces so if we were to make a list of functions here, `a = [ builtins.toString builtins.map ];`
you'd have to separate them by spaces and not add any commas so:

```nix
a = [
  builtins.toString
  builtins.map
  builtins.partition
];
```

There's a whole bunch of these. We can also look at these in nix repl, maybe that's actually a good point to mention, let's switch to the
nix repl real quick, (`nix repl`), we can, (`nix-repl> builtins`), we also have auto completion here so that's nice, 
`builtins.` and yeah I can see all the builtins (scrolling through), there is a whole bunch, there is to check the 
types of expressions, there's like builtins to map attribute sets, oh yeah, that's (`builtins.match`) a regex matching thing,
string processings, `builtins.false` interesting, (`builtins.toJSON`), to json, there is also from json, to read json
into a nix attribute set.

Yeah, I think, (`vim default.nix`), did I get the most of the nix, I don't know, maybe let's use a simple map here, 
(`a = [ builtins.toString builtins.map builtins.partition ];`). Let's do like numbers one, two, three in a list,
`a = [ 1 2 3 ];`, and let's do like a `builtins.map [ 1 2 3 ];`, and let's do like, let's give a function here,
`builtins.map (x: [ 1 2 3];`, let's say like `x` plus one, `builtins.map (x: x + 1) [ 1 2 3 ];`, `in a;`, and so
that works, adds x to all the numbers:

```nix
builtinFuns =
  let
    a = builtins.map (x: x + 1) [ 1 2 3 ];
  in a;
```

It's fairly self-explanatory. There's also some weird thing where you don't actually need `builtins.` for some 
builtins so map is one of them, `a = map (x: x + 1) [ 1 2 3 ];`, `map` is valid on it's own, so you'll see
it sometimes just like that without any reference where does it come from. `toString` we saw that as well,
`toString` doesn't need the `builtins.` but most builtins do need that prefix. 

Maybe, what do you think of this, are you confused about anything or do you have a good overview?

Matthew H.: No, that makes a lot of sense so far. 

Silvan: All right, nice, then I think let's maybe go into derivations, um derivations are a bit of a hard topic
because yeah but I guess It's fine, let's do like just a little bit about the `derivationPrimitive =`, or the
`derivationBuiltin =`. So there is some derivation,

```nix
derivationBuiltin =
  let
    someDerivation =
  in null;  
```

There is the `builtins.derivation` and this creates a derivation and what is a derivation, it's a build recipe,
and there's some very basic arguments that you need to pass to actually make that work. Let's see, if we just 
do this we should get an error:

```nix
derivationBuiltin =
  let 
    someDerivation = builtins.derivation {
    
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
error: attribute 'name' missing for call to 'derivationStrict'..
```

Attribute name missing for call, the error is again a bit messed up, but let's roll with it for now,
so derivations need a name, let's call this test:

```nix
derivationBuiltin = 
  let
    someDerivation = builtins.derivation {
      name = test;
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
error: required attribute 'builder' missing
```

They also need a builder attribute. This says which binary will build the derivation, now this is a bit hacky here, I'm just
gonna use `/bin/sh` which is one of the only binaries available in the sandbox on I think all systems:

```nix
derivationBuiltin = 
  let 
    someDerivation = builtins.derivation {
      name = "test";
      builder = "/bin/sh";
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
error: required attribute 'system' missing..
```

Um, then also a system is needed, `system =`, I'm gonna use `"x86_64-linux";` the system I'm on right now, so linux:

```nix
derivationBuiltin =
  let
    someDerivation = builtins.derivation {
      name = "test";
      builder = "/bin/sh/";
      system = "x86_64-linux";
    };
  in someDerivation;
```

```nix
nix-instantiate --eval --strict
```

And now that actually works. We can't really see the xoutputs super well here, I wanna re-format this a bit,
let me do like a, let's convert this entire attribute set into a let statement (goes to the top) and then add
an `in` at the end and do a `derivationBuiltin` here, so it will declare all the things we have above but only
result in this `derivationBuiltin` thing:

```nix
# Attribute set
let
  foo = null;
  -- all the way to the end of default.nix`

  derivationBuiltin = 
    let
      someDerivation = builtins.derivation {
        name = "test";
        builder = "/bin/sh";
        system = "x86_64-linux";
      };
    in someDerivation;
in derivationBuiltin
```

```nix
nix-instantiate --eval --strict
{ all = [ <<repeated>> ]; builder = "/bin/sh"; drvAttrs = { builder = "/bin/sh"; name = "test"; system =..
```

So yeah, we get this output, so what this really does underneath is that it takes all these arguments, calls
some internal nix primitive which creates a derivation in the actual store, that's this path here,
`drvPath = "/nix/store/y1s2..-test.drv";`, and it also tells us the output path, `outPath = "..";`, so this
means when you build this derivation description and we can look at this, actually no we can't look at it yet because,
oh, kind of a quirk, `--eval` evaluates it in like a read-only mode which doesn't write anything to the nix store.
We can do `--read-write` mode to enable this, (`nix-instantiate --eval --strict --read-write`) I believe. Ok now
we should be able to look at the store path here, we can just `cat /nix/store/y1s2..-test.drv` this path and it's
like a kind of simple description of how derivation gets built, there is like output path where should the derivation
put the result when it runs, what system is it in, the builder, and the environment (`("name", "test")`, ah actually
not, the name out, some very basic things.

Now we can call `nix-store -r`, this stands for `--realize`, you can call this to kind of manually build this derivation:

```nix
> nix-store --realize /nix/store/y1s2..-test.drv
```

Generally you don't need this but let's just go for it for now. If we try to build this it doesn't really do anything:

```nix
this derivation will be built:
  /nix/store..-test.drv
building...
error: builder for ... failed to produced output path for output 'out' at ..
```

Nix throws an error because we just called bin shell, it doesn't write the output here. 

```nix
cat /nix/store/..-test.drv
Derive([("out","/nix/store/d62..-test","","")]..
```

Okay? And so usually here, what we did now is this weird thing, `nix-instantiate --eval`, `--strict` isn't needed here,
`nix-instantiate --eval --read-write-mode` and this can then be copied, actually we do need `--strict`, then we 
copy the `..-test.drv` path, it's super convoluted and then we like the, `nix-store --realize ..`. Easier way, you
can just do `nix-build`, that's really just what nix build does. And so if you do that it will evaluate it and try
to build it in one step.

And so, also I think we can just nix instantiate it to get the derivation path

```nix
nix-instantiate
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/y1..-test.drv
```

So nix instantiate just kind of instantiates the derivation. Instantiating means to evaluate a derivation and
produce it in the store, so that this file, (`/nix/store/..-test.drv`), actually exists. `nix-build` is essentially
just:

```nix
nix-build = nix-instantiate + nix-store --realize
```

It first creates a derivation, and then tries to realize or slash build the derivation. And so let's try to fix this 
derivation in here, there's other arguments we can pass, there's some special ones, like `args` where we can provide
arguments to the builder, (`args = [ " `), and in here we're gonna do `-c` and like this maybe, `> $out"`:

```nix
-- ..
builder = "/bin/sh";
args = [ "-c" "> $out" ];
system = "x86_64-linux";
-- ..
```

So this says, shell, take a script, execute the script, and the script writes an empty file to the `out` variable, and 
in the builder the out environment variable points to the output path that nix wants you to write stuff and so this
should at least produce an empty result and build properly, let's see, that's super slow for some reason. Okay, it worked.

```nix
> nix-build
this derivation will be built:
```

So we can `ls` this (`/nix/store/..-test.drv`) I guess but it won't show anything because we didn't try anything but now
here (`vim default.nix`), we can of course do anything we want, well of course there's more complicated things, but for now,
let's do like a, can I do like.. would that work? (`args = [ "-c" "> $out <<< foo" ];`, I'm not sure that's valid shell,
`nix-build`, nope, that doesn't work. Well I don't know how to write to a file, bin shell, well I guess that can work, like
a `echo foo > $out`, all right, `nix-build`, `ls` as before, it's a file, but yeah, if we do a `cat /nix/store..-test.drv` we 
get `foo` now.

And so when you `nix-build` it puts a result symlink in your current directory, `result -> /nix/store..-test`, pointing 
to the thing it just built. As this way you can just `cat result` as well and inspect the result this way. It's not
always result so you need to watch how to, like there is some special features that change the output link name.

So this is how underneath you'd build a derivation but you kind of never need to do this yourself, because, well for one,
it's really, like `/bin/sh` doesn't really work that well. You want to use more complicated things, and this build runs in 
a sandbox so you can't use anything like from your home directory, (`args = [ "-c" "/home/infinisil/ echo foo.."]`), so that's
where nix packages comes in play. Nix packages is the package collection of nix and we can use all the packages
specified there already and within them, they kind of don't use bin shell underneath I believe, but they kind of
build up this entire tree of packages from like some bootstrap binary up to kind of all the things you want to use 
on your pc like firefox, terminals, everything. And it also contains builders for derivations that make this much 
simpler. So let's see, let's get a nixpkgs in here, it's actually also good kind of lead into some other features,
right imports, we didn't talk about imports yet, but yeah, so let's use another builtins, that's `builtins.fetchTarball`:

```nix
nixpkgs = builtins.fetchTarball
```

Fetchtarball fetches tarball, fairly self-explanatory. We can either provide the link directly, let me do that for now,
I'm gonna go to nix packages, like get a tarball for that, actually let's just use master for now, we use:

```nix
nixpkgs = builtins.fetchTarball "https://github.com/NixOS/nixpkgs/archive/master.tar.gz";
```

Generally not recommended, because this changes over time, generally you want to use pure fetchers, but yeah,
so nix packages, we can look at this, we can evaluate this `nix-instantiate --eval`:

```nix
-- ...
  nixpkgs = builtins.fetchTarball "https://github.com/NixOS/nixpkgs/archive/master.tar.gz";
in nixpkgs
```

Okay, and this gives us a directory, that was really fast actually, uh, `nix-instantiate --eval --read-write-mode`,
oh that still worked, interesting. Anyway so we can, once we have a path to nixpkgs, that actually, you can 
also provide a local path actually, we didn't look at paths yet, but you can also do, if you have a local
clone, you can just like:

```nix
nixpkgs' = ~/src/nixpkgs;
```

That's where my local clone lives. Paths are also interesting, we should look at paths but maybe not for now. So you can
reference local paths with flakes and you won't be able to anymore, uh, because this is to some degree impure,
because you can access anything here, but for now it's in the nix language. So you can also access like local paths
in your project, that's still works with flakes, so if we had like a nixpkgs clone locally we could do that

```nix
nixpkgs' = ./nixpkgs;
```

And so once we have nixpkgs we need to import it so we can use all the packages, that's done with import:

```nix
pkgs = import
```

So import takes a path to a nix file and imports it, imports the nix expression from that file, so we can
import nixpkgs like this:

```nix
pkgs = import nixpkgs;
```

By default, if it's a directory, it uses default.nix file, so in nixpkgs in the root directory there is a
`default.nix` file and that is the entry point of nixpkgs. We can also manually provide this with:

```nix
pkgs = import (nixpkgs + "/default.nix");
```

Like just concatenate the string to access a different file, but yeah, we don't need to do that, so if you would
just do this:

```nix
-- ..
  pkgs = import nixpkgs;
in pkgs
```

And evaluate this, we would get a lambda:

```nix
:!nix-instantiate --eval
<LAMBDA>
```

Which is just another name for a function, and so the root of nixpkgs is a function, and if we want to
actually access the packages we need to give an argument, and that's generally, that's always an attribute
set, so we can use currying here, so this is just like this:

```nix
  pkgs = (import nixpkgs) {};
in pkgs
```

But these aren't needed so if we do that we do get access to the set:

```nix
  pkgs = import nixpkgs {};
in pkgs
```

(`nix-instantiate --eval` returns all nix packages). So these are all the packages in nixpkgs as a single
attribute set containing all of them. All the packages, and all the package builders as well. Now in this
attribute set you can provide some other options, some common ones are `overlays =`, with overlays you
can customize packages and nix packages a bit. I like to personally override this to an empty set,
(`overlays = [];`) because by default it reads from like `~/.config/nixpkgs/overlays` or something like that,
which is kind of impure and sometimes messes with packages in weird ways. Another thing `config =` is by
default read from some impure location so I like to also override this to the empty set, `config = {};`,
and then one of the most common ones for flakes you'll see is `system =`, that's the system type, the
packages are specific to linux or darwin or something, and so I provide this here, `system = "x86_64-linux";`.
You can also, this doesn't work in flakes, but in non-flake nix you can give `builtins.currentSystem`, and it just
points to your current system, (`system = builtins.currentSystem`).

```nix
overlays = []; # Because by default ~/.config/nixpkgs/overlays
config = {}; # Because by default ~/.config/nixpkgs/config.nix
system = "x86_64-linux";
# system = builtins.currentSystem
```

And so in here we can for example say, give me the hello package, `in pkgs.hello`, if we now use `nix-build`, 
nix build hello, it will substitute hello in 99 percent of, or hello hopefully always but some packages aren't always
built by hydra. Hydra is the CI system for nix packages and you have the cache installed by default, so
you won't have to fetch in many cases. Right and now we have hello here, if we build hello, get the result
symlink pointing to hello and here we can then inspect the result and see that it has a hello binary and
we can execute this locally here `result/bin/hello`. But yeah, but how to actually build a derivation generally,
so you use the derivation builders in nixpkgs. So let's say I want to package something in in some c package:

```nix
someCPackage = 
```

It's kind of the default in nix packages for some reason, and that's using:

```nix
someCPackage = pkgs.stdenv
```

Like standard environment contains some basic packages for building C and other related bits, and
make derivation:

```nix
someCPackage = pkgs.stdenv.mkDerivation {

};
```

That's the most used by far builder for packages, and so let's try just with this to see what would fail if
we didn't provide any arguments:

```nix
let 
    nixpkgs = builtins.fetchTarball "https://github.com/NixOS/nixpkgs/archive/master.tar.gz";
    pkgs = import nixpkgs {};
    someCPackage = pkgs.stdenv.mkDerivation {
  };
in someCPackage
```

```nix
nix-build
error: derivation name missing
```

Derivation name missing, we also had that before, `name = "someCPackage";`, all right, now we got an error that
we don't have a source. And so one of the, one of the main arguments here is a source, let's for source maybe pick
`src = ./src;` and let's actually create this directory, `mkdir src`, let's also do like `echo foo > src/foo`, all
right, so we have at least a foo in there, so with a source, so by default, oh actually makefile might be good, so
by default it calls make, and the structure into phases, that's kind of the abstraction that mkDerivation provides,
so if we were to just run it like this we get an error no makefile doing nothing:

```nix
let 
    nixpkgs = builtins.fetchTarball "https://github.com/NixOS/nixpkgs/archive/master.tar.gz";
    pkgs = import nixpkgs {};
    someCPackage = pkgs.stdenv.mkDerivation {
      name = "someCPackage";
      src = ./src
  };
in someCPackage
```

```nix
-- transcriber note: currently (12/24) the error looks a bit different
--...
building '/nix/store/2fmgxgn6zsn9yj991g75wm7vvml4aq5j-someCPackage.drv'...
Running phase: unpackPhase
unpacking source archive /nix/store/zdm7f0wq0i88vhppqc9xly6bf0r1i6f3-src
source root is src
Running phase: patchPhase
Running phase: updateAutotoolsGnuConfigScriptsPhase
Running phase: configurePhase
no configure script, doing nothing
Running phase: buildPhase
no Makefile or custom buildPhase, doing nothing
Running phase: installPhase
no Makefile or custom installPhase, doing nothing
Running phase: fixupPhase
error: builder for '/nix/store/2fmgxgn6zsn9yj991g75wm7vvml4aq5j-someCPackage.drv' failed to produce output path for output 'out' at '/nix/store/2fmgxgn6zsn9yj991g75wm7vvml4aq5j-someCPackage.drv.chroot/root/nix/store/0w7rp9prqlaf6dyqwq641058kj1ddjr5-someCPackage'
```

So by default, for like make file, `vim makefile`, then have like a, `default:` which does something like `echo foo`, or move foo
to out, `mv foo $out`, well then it's like like see makefile syntax, then an install phase, although that's actually
the install phase:

```make
default:
  echo bar >> foo

install:
  mv foo $(out)
```

So this, very basic makefile, let's see if it works, `nix-build`, okay it works. So now we have a result, `cat result/foo`,
which contains `foo bar`, and so what this does underneath, it has a phases array, (`# phases: `), which gives
things like upack phase, (`[ unpackPhase`), you have patch phase, (`[ unpackPhase patchPhase configurePhase buildPhase
installPhase fixupPhase ]`) and probably some more I forgot about, but these are run in order and do various things,
so `unpackPhase` takes the source here, (`src = ./src`), unpacks it if necessary, say if you were to have provided a
zip file or something it would unpack that zipfile into the local directory in the build.

`patchPhase`, you can provide `patches = [ ];` array of `.patch` files:

```nix
patches = [
  # array of .patch file
];
```

A very easy way to apply patches to the source. Then `configurePhase` by default calls `./configure`, kind of the
default in the C world:

```nix
# configurePhase by default calls ./configure 
# buildPhase by default calls `make`
# installPhase by default calls `make install`
```

And then `fixUp` phase like some binary fixup thing does some binary patching magic..? (smiles). And so that's really
the abstraction that `mkDerivation` provides, and that's, it's generally useful, you can customize it in some ways,
so you can, all of these phases have pre and post hooks, so you can say if you want to like customize the configure phase,
and run something before the `./configure` runs you can say `preConfigure` and then a bash script here:

```nix
preConfigure = ''
  do some magic
'';
```

Then you also have `postConfigure` for after the configure, you have the same for `buildPhase` and `installPhase`,
for all the phases, `preBuild` and `postBuild` and so on. And so yeah, generally you use this kind of thing
to build packages. Now this is the most generic builder, there's more specific ones in nixpkgs. We're running out of time,
but then there's also for all the languages there are separate builders, so there's:

```nix
# pkgs.pythonPackages.buildPythonPackage
# pkgs.buildRustCrate
# pkgs.haskellPackages.mkDerivation
```

There's all kinds of builders that produce derivations and pick functions and have their own abstractions, things like that.

Matthew H: At least the naming is consistent. (laughs)

Silvan: (laughs) Yes, let's pretend it is. 

SomeoneElse: Problems in computer science.. (everyone laughing)

Silvan: All right but yeah, that's like, I think fairly basic nix tutorial, what do you think, do you, did you get most of that,

Matthew H: I think I got a lot of it, I think I'm gonna have to go back and read over the source, the back half, the derivations,
up to sort of making custom derivations, I'll need a bit of refresh on that, but that was a really interesting introduction,
yeah, thank you so much.


