[![Watch on youtube](https://img.youtube.com/vi/VkkUzggJejo/0.jpg)](https://www.youtube.com/watch?v=VkkUzggJejo&list=PLyzwHTVJlRc8yjlx4VR4LU5A5O44og9in)

Hello and welcome to the nix-hour

> https://discourse.nixos.org/t/the-nix-hour-a-weekly-nix-q-a-lecture-by-tweag/22767

yeah so let's start but before that

I want to announce the new time for August

so actually next week there won't be an nix-hour and instead the next one will
be on, August the 9th

so we switch the time to, well same time but on Fridays, starting August 9th

yeah so we have a new time every month and you can see the previous one

well doesn't really matter the previous ones really, but yeah we have a new one
every month

so different people can attend

and also before we jump into the topic I briefly want to just say something kind
of unrelated

just a nice announcement that we published yesterday

> https://discourse.nixos.org/t/enforcing-nix-formatting-in-nixpkgs/49506

so the formatting team recently worked to have an

enforced formatting for nixpkgs

so we have official format now that's nixfmt but

it's different from the original nixfmt

so it differs significantly

but yeah that's being enforced for new files and for changed files that were
already formatted before

so in the next weeks hopefully we can also make a treewide reformating so that
over time it gets enforced for more and more files

and so yeah hopefully that will limit the format bike shedding in nixpkgs a bit

so that's that, and so then let's jump into the topic for today

and that is

> https://github.com/tweag/nix-hour/issues/69

originally was `Nixos kernel overriding` but let's talk about just
`Tricky
package overrides` in general, and let's see where we can go

so I want to look into this specifically

> visits https://discourse.nixos.org/t/install-unstable-virtualbox-7-0-14/42502
> from the above issue

yeah so let's jump in

so this one is about a virtualbox unstable and so it's an override in here
`nixpkgs.config`

```nix
let
    unstable = import <nixos-unstable> { config = { allowUntree = true; }; };
  in
{
   nixpkgs.config = {
     allowUntree = true;
     packageOverrides = pkgs: {
       virtualbox = unstable.virtualbox;
#       virtualboxGuestAdditions = unstable.virtualBoxGuestAdditions;
     };
   };
```

so this is in a nixos configuration and we're specifically looking at the

if we go into

```
$ man configuration.nix
```

if we search for `nixpkgs.config`

it is this option here

```
       nixpkgs.config
           Global configuration for Nixpkgs. The complete list of Nixpkgs configuration options[1] is in the Nixpkgs manual section on global configuration[2].

           Ignored when nixpkgs.pkgs is set.

           Type: nixpkgs config

           Default: { }

           Example:

               { allowBroken = true; allowUnfree = true; }

           Declared by:
               <nixpkgs/nixos/modules/misc/nixpkgs.nix>

            1. https://nixos.org/manual/nixpkgs/unstable/#sec-config-options-reference
            2. https://nixos.org/manual/nixpkgs/unstable/#chap-packageconfig
```

global configuration for nixpkgs

we have question briefly about the nix hour

> yt-chat: Restore Bible Culture: I'm new to these Nix hours and much of the
> content is over my head. Do the past Nix Hours happen to increment from more
> simple to more advanced?

the nix-hour is kind of all over the place

if we get simple questions we'll talk about simple things

if you want to ask something

you can open an issue in the nix-hour issue tracker

> https://github.com/tweag/nix-hour/issues

it doesn't matter if it has been covered before

although we might link you to the previous episode then

but yeah if you have any simple questions, beginner questions very welcome

for me it's also the easiest to talk about

but yeah we also cover sometimes a bit more trickier topics like this one

so yeah feel free to ask simple questions as well

and today you can also ask simple questions in the chat

that are somewhat related to the issue at hand

so like package overrides and feel free to ask anything about package overrides
in the chat right now

```nix
let
    unstable = import <nixos-unstable> { config = { allowUntree = true; }; };
  in
{
   nixpkgs.config = {
     allowUntree = true;
     packageOverrides = pkgs: {
       virtualbox = unstable.virtualbox;
#       virtualboxGuestAdditions = unstable.virtualBoxGuestAdditions;
     };
   };
```

yeah so I've seen this here so `nixpkgs.config` and `allowUntree`?

I guess that should be `allowUnfree`

so actually if we try this out, it's a bit unfortunate that this doesn't get
type checked `allowUntree = true;`

well it does get type checked but only kind of very loosely

so if we try this out so let's do

let's go to the nix-hour repo the code

I should commit later we have 81

I'll just create a simple default.nix

we get packages in all sorts of different ways in various nix-hour episodes

today I'll just get it from like here I guess

> visits https://github.com/NixOS/nixpkgs/commits
>
> and copies f958e5369ed761df557c362d4de3566084e9eefb (latest commit at the time
> of recording the video)

so I'll just copy the hash and do

```nix
# file: nix-hour/code/81/default.nix
{ system ? builtins.currentSystem }:
let
    nixpkgs = fetchTarball {
        url = "https://github.com/NixOS/nixpkgs/archive/f958e5369ed761df557c362d4de3566084e9eefb.tar.gz";
        sha256 = "";
    };
    pkgs = import nixpkgs {
        config = {};
        overlays = [];
        inherit system;
    };
in
pkgs.
```

it's this here

I think you can also get that from the clone buttons somewhere

and then the hash I'll leave that empty for now and

there's also you can use flakes, you can use npins, you can use niv, you can use

there's probably couple other ways that I'm missing right now

so this is I'll call this nixpkgs then

I'll define pkgs as import nixpkgs

and then we can set the config here we'll set this in a bit but for now I'll
just leave this empty

and I'll also set overlays to empty otherwise it reads overlays from our home
config

not the case for flakes but I like doing it like this

and then system

I'll do inherit system and then I think a good pattern

and we have like templates for this as well

but I think this is a good template so this allows us to set the system if we
want

that's very useful for pure evaluation but also it works by default for impure
evaluation

and the stable nix commands

so for now let's do like a just `pkgs.`

so what is exactly being evaluated here?

we have, I guess it's a nios configuration

```
/nix/store/v8wdgwqvlx168l3cx1rrbz48xjx5d9k5-VirtualBox-GuestAdditions-7.0.14-6.1.82.drv
building '/nix/store/v8wdgwqvlx168l3cx1rrbz48xjx5d9k5-VirtualBox-GuestAdditions-7.0.14-6.1.82.drv'...
Running phase: unpackPhase
isoinfo: Warning: Joliet escape sequence uses illegal space at offset 3
Creating directory install
Verifying archive integrity...  100%   MD5 checksums are OK. All good.
Uncompressing VirtualBox 7.0.12 Guest Additions for Linux  100%
LICENSE
...
src/vboxguest-7.0.12/vboxsf/Makefile-header.gmk
src/vboxguest-7.0.12/Makefile
Running phase: patchPhase
substitute(): ERROR: file 'src/vboxguest-7.0.14/vboxvideo/vbox_ttm.c' does not exist
/nix/store/10i1kjjq5szjn1gp6418x8bc1hswqc90-stdenv-linux/setup: line 131: pop_var_context: head of shell_variables not a function context
error: builder for '/nix/store/v8wdgwqvlx168l3cx1rrbz48xjx5d9k5-VirtualBox-GuestAdditions-7.0.14-6.1.82.drv' failed with exit code 1
```

is this an ISO image build?

virtualbox guest additions

we might want to

it would always be good if you have trouble and need some help with that

to make it as reproducible as possible, so ideally

also like if the command you're using to test this

and yeah anyways in this case well let's just do, I know let's do something
simple

`pkgs.hello`

just to make sure it works

```nix
# file: nix-hour/code/81/default.nix
{ system ? builtins.currentSystem }:
let
    nixpkgs = fetchTarball {
        url = "https://github.com/NixOS/nixpkgs/archive/f958e5369ed761df557c362d4de3566084e9eefb.tar.gz";
        sha256 = "";
    };
    pkgs = import nixpkgs {
        config = {};
        overlays = [];
        inherit system;
    };
in
pkgs.hello
```

so `cd nix-hour/code/81`

so we have this default.nix now and we should just be able to do nix-build in
here

``

found empty hash

so let's wait for a second until it gets that done

> yt-chat:
>
> Restore Bible Culture: Perhaps a better question is, what would be a good
> primer to better prepare for this level of content?

I feel like there's a bunch of nix-hours that are a bit simpler

but also what would be interesting if you have like

maybe watch some nix-hours and just see what kind of things you're not
understanding

and you can make a single issue in the nix-hour repository just listing a bunch
of these

like that would actually be really helpful because

for me as someone that has been using ni for a while longer it's almost
impossible to know what beginners struggle with

and so I really need to like look into into like help forums and and chats and
so on to see what people are asking for

so if you struggle with something feel free to ask about it just list it out

see what kind of things you run into what problems you encounter and then we
could cover those

and that could be the preparation for nix-hour

could be the nix-hour we do as a preparation for for others but yeah

it's a lot of different things you might want to learn

but yeah okay hashes, hashes

```nix
# file: nix-hour/code/81/default.nix
   sha256 = "00ba9h4hlhs0hszx5lmh0wi07j3vriafv6llhwc6vb99wy81rn14";
```

so I mean I can also explain things a bit long here as we go

also here

well I guess nix language basics would be a good requirement

but in this case

well I'm not sure how much we can go into that but yeah

we have

`fetchTarball`

we have functions we call those with an attribute set here

```
{
  url = "...";
  sha256 = "...";
}
```

it's kind of like a json thing

and we don't always need this hash but for purity it is nice

```nix
# file: nix-hour/code/81/default.nix
   # sha256 = "00ba9h4hlhs0hszx5lmh0wi07j3vriafv6llhwc6vb99wy81rn14";
```

so actually in here we this would also work so if I try building this

it takes a bit longer actually to evaluate because it needs to redownload this

> NOTE: as of writing this post, with nix version 2.30.2
>
> nix-build with the hash commented was instant, so the above statement of
> re-downloading or being slow no longer applies, I assume some kind of tarball
> caching being done, independent of the hash provided

but this works as well and it gives you the exact same result

but because this is a URL and this GitHub URL could just randomly change

because of that we need to actually provide a hash for nix to know that, oh this
is never changing

so actually if we don't provide a hash and try to run this with pure evaluation
mode

```
# from shell history autocomplete
$ nix-build --pure-eval -E '(import (fetchGit { url = ./.; rev = "'$(git rev-parse HEAD)'"; }) { system = "x86_64-linux"; }).hello'
```

and there is pure eval in the old CLI but it doesn't work like quite like that

so you need to actually do something a bit messy here

let's see could we actually

this is a bit too messy so we could do flakes instead and that's the kind of the
main way people use pure evaluation mode outside of that

it doesn't matter that much but I prefer it here because of the speed because if
I do this it's kind of much faster

```
$ nix-build
/nix/store/kwmqk7ygvhypxadsdaai27gl6qfxv7za-hello-2.12.1
```

because nix already kind of knows where exactly this path has to go and we can
also see this here

so if we do just output nixpkgs

```nix
# file: nix-hour/code/81/default.nix
...
in
#pkgs.hello
nixpkgs
```

this is entirely ignored

```nix
# file: nix-hour/code/81/default.nix
  pkgs = import nixpkgs {
    ...
  };
```

so we just have a variable definition and use it right away

```nix
let
    nixpkgs = ...;
in
nixpkgs
```

and do a, not a nix-build

we can't do a nix-build because it's not a derivation

nix-build actually underneath it does a there's kind of two steps in derivation
generation

the first one is `nix-instantiate`

and this one already fails

```
$ nix-instantiate
error: expression does not evaluate to a derivation (or a set or list of those)
```

so this essentially evaluates the nix code and turns it into a build recipe,
that's a derivation

but even that already fails because it's not a derivation instead

we can use nix-instantiate eval

```
$ nix-instantiate --eval
<LAMBDA>
```

so that's okay that turns into `<LAMBDA>` and

that's also a bit of a weird thing but if you just evaluate this

this is of course a like there's a function here

this is, these are function arguments or this is a single function argument

```nix
{ system ? builtins.currentSystem }: # argument
... # The return value
```

and this is the return value

so Z yes it turns into a `<LAMBDA>` that's a function but

we can also

yeah there's some autocalling involved sometimes so we saw earlier

that nix-build without

this is getting a bit, we're seeing all the quirks in nix right now

but yeah if you just nix-build

there's some autoccalling going on because a Lambda, a function is not actually
a derivation

but still it can actually build it and so it does like if you have these default
arguments

`system ? builtins.currentSystem`

this is a default argument

it can call these functions automatically from the CLI

so if I remove this for example then it can't do it anymore

```nix
# file: nix-hour/code/81/default.nix
{ system }:
...
```

```
$ nix-build
error: cannot evaluate a function that has an argument without a value ('system')
       Nix attempted to evaluate a function as a top level expression; in
       this case it must have its arguments supplied either by default
       values, or passed explicitly with '--arg' or '--argstr'. See
       https://nixos.org/manual/nix/stable/language/constructs.html#functions.
       at /home/tweagysil/nix-hour/code/81/default.nix:1:3:
            1| { system }:
             |   ^
            2| let
```

yes and then it complains

then we'd have to provide it manually

> with '--arg' or '--argstr'

so anyways

I just briefly wanted to show this here

so nixpkgs

```nix
# file: nix-hour/code/81/default.nix
{ system ? builtins.currentSystem }:
let
  nixpkgs = fetchTarball {
    url = "https://github.com/NixOS/nixpkgs/archive/f958e5369ed761df557c362d4de3566084e9eefb.tar.gz";
    sha256 = "00ba9h4hlhs0hszx5lmh0wi07j3vriafv6llhwc6vb99wy81rn14";
  };
  pkgs = import nixpkgs {
    config = {};
    overlays = [];
    inherit system;
  };
in
nixpkgs
```

and what is this actually maybe a better way to explore this is nix-repl

so enter nix-repl

`$ nix repl`

and now I want to inspect this file

and so how do we do that we can say

`f = import ./default.nix`

now f is the value of that file

```nix
nix-repl> f
«lambda @ /home/tweagysil/nix-hour/code/81/default.nix:1:1»
```

and we can also see here that's a Lambda

but now we can actually call it

and we don't need to provide an argument here

because there is a default so we could just call it with an empty attribute set

```nix
nix-repl> f {}
"/nix/store/ka83qvpqkcbqsq8i2zhxribpfd32hcf7-source"
```

and now we get this back so this is actually a string

and it's not a derivation whereas if we change this to `pkgs.hello`

```nix
# file: 81/default.nix
...
in
pkgs.hello
```

and well if you just rerun this

```nix
nix-repl> f {}
"/nix/store/ka83qvpqkcbqsq8i2zhxribpfd32hcf7-source"
```

it won't change

we need to do colon r `:r` that reloads all the files

```nix
nix-repl> :r

nix-repl> f {}
error: undefined variable 'f'
       at «string»:1:1:
            1| f {}
             | ^
```

and oh yeah we also need to redefine f

```nix
nix-repl> f = import ./default.nix;

nix-repl> f {}
«derivation /nix/store/fqs92lzychkm6p37j7fnj4d65nq9fzla-hello-2.12.1.drv»
```

but yeah this turned, is a derivation then and actually the repl is also a bit
deceiving here

like what is actually derivation we can kind of see the more internals

by avoiding the nix-repl prettry printing it in this way

if we just set the type to something else, something that is not derivation

```nix
nix-repl> f { } // { type = "derivation"; }
«derivation /nix/store/fqs92lzychkm6p37j7fnj4d65nq9fzla-hello-2.12.1.drv»
```

so this is the what the normal type is but if we set it to an empty string we
can see what it actually is

```nix
                                                                                                                                                                                                                                17:48:39 [0/167]
nix-repl> f { } // { type = ""; }
{
  __ignoreNulls = true;
  __structuredAttrs = false;
  all = [ ... ];
  args = [ ... ];
  buildInputs = [ ... ];
  builder = "/nix/store/m101dg80ngyjdb02g6jwy80sr7kzj26g-bash-5.2p26/bin/bash";
  cmakeFlags = [ ... ];
  configureFlags = [ ... ];
  depsBuildBuild = [ ... ];
  depsBuildBuildPropagated = [ ... ];
  depsBuildTarget = [ ... ];
  depsBuildTargetPropagated = [ ... ];
  depsHostHost = [ ... ];
  depsHostHostPropagated = [ ... ];
  depsTargetTarget = [ ... ];
  depsTargetTargetPropagated = [ ... ];
  doCheck = true;
  doInstallCheck = true;
  drvAttrs = { ... };
  drvPath = "/nix/store/fqs92lzychkm6p37j7fnj4d65nq9fzla-hello-2.12.1.drv";
  inputDerivation = «derivation /nix/store/xilxxssfhk68w69kxfg769mciq4354d3-hello-2.12.1.drv»;
  mesonFlags = [ ... ];
  meta = { ... };
  name = "hello-2.12.1";
  nativeBuildInputs = [ ... ];
  out = «derivation /nix/store/fqs92lzychkm6p37j7fnj4d65nq9fzla-hello-2.12.1.drv»;
  outPath = "/nix/store/kwmqk7ygvhypxadsdaai27gl6qfxv7za-hello-2.12.1";
  outputName = "out";
  outputs = [ ... ];
  override = { ... };
  overrideAttrs = «lambda overrideAttrs @ /nix/store/ka83qvpqkcbqsq8i2zhxribpfd32hcf7-source/lib/customisation.nix:152:73»;
  overrideDerivation = «lambda overrideDerivation @ /nix/store/ka83qvpqkcbqsq8i2zhxribpfd32hcf7-source/lib/customisation.nix:151:32»;
  passthru = { ... };
  patches = [ ... ];
  pname = "hello";
  postInstallCheck = "stat \"\${!outputBin}/bin/hello\"\n";
  propagatedBuildInputs = [ ... ];
  propagatedNativeBuildInputs = [ ... ];
  src = «derivation /nix/store/zrkncfsisvhf5vwsk0wal9kf925bfafw-hello-2.12.1.tar.gz.drv»;
  stdenv = «derivation /nix/store/3j3885jjszgd49vn6jm49jqg1qbiy44i-stdenv-linux.drv»;
  strictDeps = false;
  system = "x86_64-linux";
  tests = { ... };
  type = "";
  userHook = null;
  version = "2.12.1";
}
```

it's a whole bunch of attributes

but there's some important ones

there's like, where is it

name is important `name = "hello-2.12.1";`

outPath is important
`outPath = "/nix/store/kwmqk7ygvhypxadsdaai27gl6qfxv7za-hello-2.12.1";`

that's where the the build generates the final output

yeah anyways we're going a bit in depth here

let's see I'll briefly read the comments

> yt-chat:
>
> Restore Bible Culture: Awesome, I've been using it to administer 3 machines
> with 3 users and really like it. I've been using streaming machines with three
> users and really like it

nice

> yt-chat:
>
> confus: that's where nix really shines, sharing configuration between many
> machines and reliably re-deploying them if you have to

yeah yes but so today we want to

let's go back to this one here

so specifically we have this virtualbox in here actually for that we wouldn't
want to build hello then but virtualbox instead

virtualbox so this is the standard package set and if we do that let's see can
we build a virtualbox

hopefully it's pre cached it might actually probably doesn't take too long to
build it might be like a wrapper derivation which does need to actually do very
much

okay so this we can ignore for now I think the more important one is the
virtualbox guest additions

for this so well actually something I don't want to ignore is this here

package overrides

so it's actually I think it's used a lot throughout the documentation but this
is actually kind of outdated

and the the newer way of doing this

so actually let's verify that this actually works first or I'm actually not sure
how well this is going to work

but yeah let's say virtualbox guest editions

let's just copy this although it is commented out not sure why exactly

so virtualbox guest editions and for this maybe let's just set it to the

well I guess here's the problem then so we want to override it with something

but what is actually the old value in this case I think it's packages and but
it's not like super clear

but we'll try it in this case so I'll just do something like very simple

and maybe how about this we do an overrideAttrs this is a way to override the
derivation attributes

so we can change the the build recipe more or less directly

so these are the old so overrideAttrs takes a function which gets the old
arguments as an argument

now we can provide new ones and it will override them like that

so something simple we can do here is to set the name to something different so
we'll just do this so old.name so we maintain the old name but then we add a
suff and that will be modified all right and now let's try this again now
hopefully this will change and actually before we do that hold on let's comment
this out for now and we're going to use nix-instantiate here uh so
nix-instantiate evaluates the entire nix language thing and this we end up just
with the build recipe for this derivation so if this here has an effect the
build recipe should already change here we don't even need to build it to notice
that something changed because the hash should be different let's try this and
it doesn't it's the same thing so we already know that this won't affect
anything actually if we try to build that now it will just use the the already
built thing from before because these derivations know exactly where they need
to end up with and that's right the right here we can also we can also inspect
this with nix-store -q outputs I believe oh yeah or there's also I think a there
bindings um maybe not oh well let's query bind oh binding all right so we can do
bind out path or is it just out oh it's just out um okay oh and there there's
also outputs so you can have multiple outputs and in this case we have two but
the default one is the first one so that would be out in this case so that um
anyway so yeah the build recip knows where it's going to end up with but it
doesn't change in our case so we know the uh the override doesn't have any
effect so then what the next step is is to look into the source code to see like
how does virtual box and virtual box guest editions relate to each other did I
make a typo here maybe should it be this well is that even the right thing does
packages. virtual box guest editions even exist actually let's try this out
first because uh we can also build that and like independently of virtual box um
so I think I'll actually not specify virtual box here specifically such that I
can do nix-instantiate and then select the attribute from packages that I want
from the CI so like I could do this here the same thing from before virtual box
this gives us the exact same thing but I can also then specify guest additions
and now here we should see a change so I'll come this out again viralbox guest
additions and we actually this actually doesn't exist so packages. virtualbox
guest editions doesn't exist so like also if we override it we would have gotten
the same thing right attribute missing so uh I think that calls for looking into
the uh into the source code how they need to be connected um there's also some
more here here and more discussions um where we could also figure something out
uh but okay let's look at the source code um and try to figure it out ourselves
so I'll go into nixpkgs here so this is a just nixpkgs clone um and by the way
if uh you don't even need to clone n packages to have a copy of it available
like if you have if you install stuff from nixpkgs you have it available and
that's that comes with a default installation of nix and so you can also get
that get a path to that using nix-instantiate find file nixpkgs so in my case
this points here if you use channels I wouldn't recommend using channels but if
you use them then it points somewhere else and if you use flakes it also points
somewhere else um but yeah this is a very generic way of finding a nixpkgs clone
so in my case I could go in here and there's an nixpkgs in here that I can use
to to look at and maybe a really brief plug I have a a kind of fairly simple
tutorial for how to not use channels in for n but also not using Flakes I'm just
using a ni in in this case but you can also use endpins it's a fairly simple way
to to get this done so that's that would be SX um I'll leave this here for a sec
anyways so let's look at the source so I'm well I you also need to make sure
this the right version I suppose uh let's actually make this sure so so I picked
the latest Master commit here so I will also check this out here um and so this
is something you couldn't do with just the nix-instantiate find file location
because that usually isn't a git directory um so for that you would need a clone
so we we don't have this revision right now so I need to pull from master and
actually I'll do a fetch Upstream to fetch all the revisions from Master Okay
and now I should be able to switch to this and I'll need a detach here okay so
uh virtual box now now how can we find where where the virtual box is defined
and uh for that I'm going to use the repl and I load nixpkgs into the repl right
away using `-f .` and so we have virtual box in here uh that should be the
derivation the same one from before the N1 thing yes we can compare these hashes
uh well the first couple characters are usually usually enough um yeah like you
could also end up with with ones that are like almost the same uh or with way
more characters being the same um we have a question so you use a method in nix
that doesn't use channels or flakes or did that comment apply only to this
content uh to this context uh yes I use a it applies overall I don't use
channels and I don't use flakes uh for almost everything and actually here this
example we just wrote is also a way of not using channels and not using flakes
uh because I just I just fetched nixpkgs it like I just pinned it like this and
uh in Sonic here or using ni or endpins or there's other ways uh it's really
just taking this and putting it in a Json file and then importing from that Json
file instead of uh having it in line with the code so this allows you then to
way more easily update it so you can have tooling and that's what ni then does
to just update these hashes and these URLs instead of having to manually do it
so yeah that's that's my kind of preferred way of doing things and and flak is
by the way very similar like flakes also just has a lock file for this instead
and uh Imports it by by itself uh but okay so we have virtual box in here I want
to get to the location and uh sometimes we can use meta Doos for this this is
something that gets kind of implicitly added to um to most attributes and
packages and here we get this path back out and that seems to be pretty accurate
to me so and it let's open this here on this other window it specifically points
to line 275 and if we go there we should see why 275 we can see description here
well it's it's not obvious from this but um where this comes from is because
underneath it does something like this builtins do unsave get attri pass so this
is a builtin and it's unsafe because it does something impure and so
specifically it allows you to get the location of attributes so in this case it
specifically got the location of this one so that would look like this we get
the location of the description of virtualbox do meta so then we get this back
and here is the line 2 275 and it's impure because if I uh if I do this or
impure or not referentially transparent would be another way to word it if I
change this here Rel load the files and try this again then we get 2 276 so even
though it's the exact same expression you get a different result that's that's
the definition of impurity pretty much and so that's why it's unsafe um and
shouldn't generally be used in like actual code it's it's way more useful and
and is okay to use for like debugging and error location information and stuff
like that um oh yeah the next edit thing yes let's actually use that as well
yeah in the new and still experimental CLI there's the nix-edit which allows you
to do actually is this going to be very slow

it is going to be very slow and does it actually open the

okay I guess that doesn't quite work

does this work virtualbox I think this should work better hopefully

still copies like

hold on

oh what if we do that, this seems to work yeah

although it seems to like copy things around which I'm not a big fan because
nixpkgs is really big

but I don't think this should probably okay anyways

oh yeah and actually this might work if we do

oh no I'm actually not sure anyway

so we have the location it is right here and so let's see if we can find any
guest edition stuff in here

and I can see something right here and that's also the iso thing

I didn't really know how the ISO so as how something about ISO was related to
the original ticket here but we can see it here now

so virtualbox guest editions ISO let's see

let's make this a bit bigger, okay

so something to watch out for is these arguments up here

and so these so this is the package kind of meta recipe in a way

so this returns an actual package like something you can build, a build recipe
that's down here

that's the derivation, derivations are these build recipes but up here you have
arguments for that

and you need to provide these arguments to get build recipe out of the here

so the question is what arguments are provided and also these ones here can be
customized to something different

and you can overwrite these so well by default they get provided from the
packages directly

so for example SD here comes directly from so we loaded packages here it comes
directly from packages. sdn so that's provided in this argument fetchurl comes
from URL and so on

but these ones here don't usually come from nixpkgs so if you have Java Bindings
that doesn't exist

but there's a default so it uses that default instead

but you can also override these so if you take virtualbox

you can use do override and that's kind of one of the i'll say most useful most
commonly used override functions

you can do this and for example say well we want to change the Java bindings to
be false instead

so we don't want to build it with Java bindings would be the meaning of that

so Java bindings equals false and now we should get a different hash

and indeed we do it's not the well previously it was this one

but now it's this one so it actually changed something about the derivation

this also works for, like this works for all of these arguments

also the ones that are provided by default and don't have a default well lot of
defaults in here

but for example we could say stdenv overwrite this to stdenvNoCC not sure if
that would actually work

yeah I guess it doesn't doesn't work but yeah that could also be overwritten

but yeah so something I don't see here is virtualbox guest additions

there's some guest stuff here but yeah guest editions is only comes from down
here

so virtualbox guest editions ISO so it uses call package here um it's a call
package actually fills in these arguments ments this file itself the virtual box
default. n is also called with a called package from somewhere else and that's
how these arguments get filled so in this case we have another file we have
guest editions ISO which also gets looks kind of like this so if you go in here
it's much simpler and oh this is actually just fetches something it's not even a
a real build um okay uh but then the question becomes how do we change this and
that's actually might be kind of tricky but I mean that's what the episode is
about right so how do we change this because it's it's not in the override
arguments up here it's just down here in in this Lettin statements and that's
why many people are saying that Lettin statements are kind of bad because you
can't override anything in them and so there I see two ways or actually three
ways we can we could change this and so so yeah let's let's look at those so one
of them is to to see where this is used so the legend statement like we can do
Fu equals 10 in here and it wouldn't be used uh then it would wouldn't also
matter but where is this actually used so let's go down here virtual box guest
editions let me go down here um here so well actually no this is not where it's
used uh here it is used virtual box Gest editions ISO and so this is apparently
an attribute passed to make derivation and that means we can use the same thing
we did earlier with the override address and virtual box guest editions uh yeah
we can use the override address for that so we have override which overrides
these arguments up here but we also have do override aters which overrides the
attributes down here with that are passed to the derivation um yeah so let's try
this out uh let me exit here and I'm going to change this up here and say so
let's just write it down here so we have virtual box equals and now we take the
old one although actually package overr right isn't that great to use we we're
going to change that hopefully in a second so virtual box and then override ERS
so we want to change the virtual box guest editions ISO attribute um okay and so
how do we well we have the old value here I suppose this one and then let's I
mean let's try the same thing let's do the same thing as up here and uh do it
like this all right so there's a bunch of old variables in here let's let's make
them a bit more distinguished uh okay and that should in theory work let's try
it out so nix-hour/code/81

let me actually move around some things a bit

so we have the virtualbox code down here

we have the our nix code file up here and let me make this like this so we can
see the entire thing okay now let's build a virtual or actually let's just do n
instantiate d a virtual box virtual box and we can see a different hash now so
let's actually just also verify this um if we comment this out it is the old
hash and so actually that did actually change something that's good um so let's
I mean let's also see what actually changed so a kind of a useful utility for
that is next diff next- diff so let me actually get the attributes the
derivations again comment this out all right we have these two so these are
already buil recipes whatever we do with these paths well whatever we do in this
next file won't affect the of these paths anymore so we can do a next diff of
these two to see what changed and let's make this a bit bigger and let's scroll
up here so we can see the set of input derivation names do not match so there's
different inputs for this derivation so one of them is modified that's exactly
what we expect to see and also down here uh this is a bit harder to read but
it's the same thing with Dash modified at the end all right so that makes sense
and same here so uh that looks pretty good let's try building it as well so let
me uncomment this again let's build- a virtual box and let's see how long this
actually takes I hope it doesn't need to compile anything oh but it it looks
like it might need to compile something because it's downloading a lot of
dependencies yes this is actually a lot okay hold on what we can do to kind of
see how long something takes to build we can go to Hydra that's the build farm
that builds everything in next packages or almost everything so Hydra has a has
different projects in our case we want the next package is one all right takes a
second to load right and then there's different job sets um these are kind of
different uh well they have different in they have different branches they track
and different inputs and different conf configurations in our case we want the
trunk one that's kind of the the good default that built from the master
playground um from the master branch and so we can go in here jobs and find the
virtual box one virtual box all right it's a bit slow because there's 240,000
jobs that's understandable shouldn't take much longer though uh here we go
there's a lot of cases though but yeah down here we have it so I'm on X 8664
Linux here's the virtual box derivation we can go to like any of these These are
successful builds uh if something fails we see R cross so I'll just click to the
latest one here and then we can see here duration 8 minutes 56 seconds so that's
maybe a bit too long I'm not sure if I want to wait for that and uh yeah we can
see here it starts compiling um but okay so in in theory that should work we
didn't actually change much for now um but yeah okay uh let's go let's go back
to here oh and actually I wanted to do the package over thing so that's a bit
outdated instead the newer thing to do is to use overlays and so we can see it
here that's these another argument to packages and uh so in here overlays is
list of overlays and each of them is a function that takes two arguments and the
first one is we call that final second one we call that prev and it returns an
attribute set so here the cool thing is that you get access to both the previous
thing the thing that you you want to override so in this case that would be
virtual box guess editions but you can also get access to the wait flipped it
around uh the so the previous one that's here that's the kind of previous
versions before you these changes are being made but you can also get access to
the final changes so if you have like and I'm not sure how well we can
demonstrate this here but well let's just convert it to the overlay for now so
actually I'll delete this one we don't really need that apparently so I'll just
move this one in down here and instead of packages here it's prev I mean we
could have also called this argument prev I think that's what it is yeah prev is
kind of the the common convention and so then we can remove this package
overrides overlays is like strictly more powerful than package overrides I'm I'm
like 99% sure at least we keep the config as empty so it doesn't read stuff from
imperior locations and uh yeah let's try this again it should be exactly the
same thing instantiate virtual box that I think if I remember correctly that's
the same hash as before yes and maybe also something here uh so next build is
just instantiate instantiate followed by a next door d realize effectively and
so in this case we did an nix-instantiate already so another way of then
building this derivation which then actually doesn't need to evaluate any nix
code anymore so like we could also just do like a some random syntax errands in
here but we can still run the Second Step here of next door realize of that
derivation um so that works because at this point the everything we specified in
this next file is already represented in our derivation here and it's it's a
pure path we can't modify this anymore um yeah so that's another way of just
building things and understanding it a bit um QT Bas is never a good sign for
the build time maybe leave package overr rights come to out for poster posterity
uh yeah I guess we can do that let's let's do it like this use overlays instead
uh okay so we have that now something I want to oh yeah we wanted to cover other
ways of overriding things so we this is one way and so what would be one other
way is like super hacky but it works in kind of more cases and so we need to
look at how this is called so call package is used here and we can't override
this one but could we override individual parts from here and specifically here
call package can we overwrite this so I'm going to try this so let's comment
this out let's copy this one over here kind of like this this so where does call
package come from well call package is it's up here in these arguments and we
can overwrite these so that kind of works but then we also need to watch out is
call package used in other places because this gets into the kind of slightly
hacky business uh so let's see is where's call package all used so it's used for
guest editions it's only used for guest editions so that will kind of work
somewhat easily but it's it's of course like very very hacky um because as soon
as you use call package for something else it's going to break but yeah it's in
case of emergency this would also work in theory so we can we can do this we can
say call package is old. call package um but actually it's a function so uh and
it takes two arguments um so we have a file we have a let's call this a and we
call this with fent a so this is should be exactly the same thing still so let's
do just try this next instantiate this um can c a function to string what did I
mess up here Lambda call package line 20 call package oh I'm using override
atress here uh so yeah this is these arguments need override not override ESS
all right let's try this again and uh that works and we can still see our old N1
JJ hash here it didn't change anything yet now we kind of know and we can
actually do also like a trac in here uh let's do one here yeah so built-in.
trace and we can say call package on F and I'm going to do two string here so we
don't copy the file actually let's see what happens if we don't do this so let's
just instantiate this and we can see here Trace call package on file uh but so
the the reason why we want to use two string here is because there's no need to
import this file into the next door and so if you don't do this it's going to
well if used to string it's going to trace uh this one which well it's already
in the nix store and so actually this was kind of the second import of it into
the nix store um but actually this is kind of surprising me right now why is
this already in the nix oh no that makes sense uh that does make sense because
we have we fetch this and this itself returns n package in the n store path all
right so we have call package and it only gets called on this guest editions ISO
thing and we also have the result of that here notably so we have uh let's do
this here so we have result equals this in result so we can also say built-in.
phas result uh is this one here um and so in this case this is a derivation it's
not a path so we don't need to do any two string thing and if we try this we can
see the result is this vbox guest editions ISO thing so now we can also just
override this like we can take this result here and do an override address on
this and here we can do the exact same thing name let's change the name like
this and old let's I guess let's do this here old Prime as well and uh let's try
all right we can see the result change we can also see the final derivation here
changed all right so this is actually very hacky let me let me put this just in
bold hacky but it works um yeah so maybe like okay this this is a bit dangerous
because we don't really like if if this derivation gets changed if this file
gets changed to suddenly also use like something else like what if we have I
don't know uh I don't know I know hello equals hello. override address or
actually call package call package hello then this would be problematic because
we'd also override this hello thing with with something else so what we can do
is to do an we do an assert or do an a condition here and say something like
this where we say um let do let's do original result hold on Vim Vim gripes so
this or original all right then we change this to original um or actually the
result should then be if the original do name or let's say p name equals equals
uh something I'm what was it here uh vbox guest editions 7 I so that thing
actually I'm not sure if there's a version even here so let's just check for
name if it is this then do the override if it is not then don't do the extra
override I mean it's it's hacky but if you if you need to use it um this doesn't
work so let's try it out so n instantiate this should give us the QA W yes and
uh if we did something else it would give us something different um but here we
also have version numbers in here which isn't that great so we could also do
like a um we do lip. match on with like a Rex this I I mean we we are already
here might as well go all the way right so that's something like I mean maybe
just do okay maybe let's not use regx let's just use lip. has prefix that's kind
of easier a bit so has prefix vbox guest editions um yeah why not old uh
original. name and we need lip in here oh and this is actually interesting so
where do you get lip from in overlays that would well we don't override lip in
our case so we get it from final so final. lip if you were to override lip you
would need to use um pref instead so let's say we do lip equals uh pr. lip or
actually let's try final here so final. lip do extend that's a way to extend lip
itself with an overlay so kind of recursive overlays here um or nested overlays
rather so let's say we we want to add our own function here let's say V equals
10 and uh we can do that so if we now do like nix-instantiate eval d a lip. Fu
um that oh yeah that actually doesn't work so because we are overriding lip here
we need to use prev here instead so anything you override in in an overlay
should come from prev so we override lip here should come from prev um anything
you don't override should come from final so this here does work all right we
have 10 in our own lib now um but also there's this a rare case where you need
to compute the list of attributes right like like kind of earlier here so um so
like for example we we want to trace all attributes that we're setting in this
overlay uh we might want to do that with a lipop map address here and like say
name value and then like builtin do Trace uh name and we can actually do we can
reduce this to that so where should lip come from here so we don't override it
we don't override map address or or live in this at this location so we might
try final. lip but this will fail uh infinite recursion and that's a bit of a
like overlays need to know the attributes themselves before can uh kind of use
the overlay so in this case there we need to use prep uh just because there's no
other way of doing it and so yeah that then Works uh let me put this like maybe
here and actually I'm going to format this file all right so uh we have that we
have that okay now um I was mentioning another way of overriding something and
let's try that so what we could imagine doing is to actually override this file
itself with something different so make a patch for this file and then apply to
nixpkgs and uh can of use it that way so let's try this so I'm going to go to
this file and uh we're in G here so we can kind of right away modify it so let's
say the name we want to change the name so let's do this here and say right we
were're going to do the same modification modified all right and now let's
generate a diff for that so I'm going to do get diff and uh well there's also
that but we only we're only interested about this um so let's actually do let me
do a check out-p so we can say remove this change so yes to that no to this one
okay get diff again now we have exactly what we want now I'm going to Output
that diff to nexr code 81 and that's my let's call it vbox uh patch sure all
right we now have in our directory here we have v. box. patch so that's stiff
here all right now we need to apply it and actually let me comment this out
before we go ahead all right so we have our original nixpkgs up here let's do
like let's call that original but now we're going to define a new one nixpkgs
equals um actually it's a bit annoying because we need to import a function to
even patch the thing so we kind of let's do it like this packes original equals
import nixpkgs and here we do kind of the very simple import just this overlays
equals that um and then inherit system so this is we just use this to get a a a
patching function and so what we can do is package is original and say well how
do we apply the patch uh we can use make derivation that has the patches array
the patches attribute that we can use so sdn make derivation uh then we say we
need to give a name so we say next pack is patched there's a I guess let me use
this but there's a better way of doing this well let me use a better way right
away there's Source only which doesn't need any like build phases or anything
like that and it works for patching things so we can do the source in our case
that's going to be our nixpkgs original all right and then we can use patches to
say apply this vbox do patch to that nixpkgs so yeah now uh packages is just
importing nixpkgs here uh with our overlays although in this case we don't need
the overlays anymore we just do the lip thing um and it should still give the
correct hash that we expect so let's try this out and actually if we do this now
it will require infinite recursion

oh nixpkgs original should be original

all right so yeah this will actually have to use Import From Derivation

which has a import from derivation it has a nice

oh hold on

nix manual table oh it's not here anymore

hm oh I think it's in unstable or the latest nix version

import from derivation yeah that has a a page now describing this in the nix
manual

so um did we actually see that import from derivation was necessary here

well it is necessary because we import nixpkgs here

which is a derivation in our case and that's pretty much exactly the definition
of import from derivation

and let's see what is the the hash QA W I'd say that's exactly the same one we
had before with the other ways of patching things

let me also just check what happens if we remove the patch or actually let's do
it like this just import the original one

we don't need that Trace here anymore yeah let's just comment this out like this

see yeah that's n one JJ and we can also try this one again and just verify it's
the same and that is a casee q aw and this one here nixpkgs qaw right yes all
right

I'll briefly read comments

could you poke them for reinviting people like oh yes I mean maybe brief
explanation of what that means reinvite there's not that Miss

oh here this one so in nixpkgs

let me briefly give a bit more context so we have a lot of package maintainers

and if you want to get requested for a review for those packages that you
maintain

you need to be in the organization so if I pick like random PR here try to add
like

I don't know I happen to know that notifications which is kind of very confusing
but we I can't add them here because they're not in the organization and so
there's a kind of useful script that if someone adds themselves to the
maintainer list and we have a

if you want to be a package maintainer you need to do that anyways

then it ultim automatically invites you to the organization

without any permissions just read only member of the organization

yeah so you get an automatic invite but that expires after like a week and so
sometimes

so we have this issue here where if you missed it you can kind of request being
added again and occasionally someone goes in here and like just adds the people
that have missed their invites in

hopefully we can automate this a bit more in the future but it's not a lot of
cases so it's very fine right

but yeah I'll keep this open here so I can look at it later but yeah

otherwise I think this is good so you could try running in read only mode to
show that IFD is necessary

ah yes we actually could and maybe let's do that real briefly still

so read only mode

read only Dash mode we won't see now because it already built the thing

but we could see it if we do it like like nixpkgs Das patch make that uppercase

yeah we can see it now uh path is not valid so readonly mode

well actually readonly mode would be too restricting anyways we'd have to say
allow import from derivation equals false does that work

it doesn't quite work

option allow import from derivation false like this

yeah that's that works so yeah I cannot build because I'll allow import
fromderivation is disabled

and that's not the case with the with the pre with the other ones but yeah so if
we enable this then it works

anyways yeah

let's conclude it here thanks for watching and hope to see you again
