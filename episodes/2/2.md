Silvan: All right so yeah, just to re-iterate we have some people from outside of tweag joining now,
open to the public now, we're like half tweagers, half from outside, so that's awesome, so yeah, open
to anyone, any questions, things they want to have taken a look at, issues, PR's, anything nix really.

Quentin Aristote: I do have a question. I know about overriding and overlays and it's useful but, and so for 
example what you can do is you have a packages as nix packages and if you want to change the input you 
can use that to change the input and thats nice, but what am I supposed to do when you want to change 
something that is not in the arguments of the function that defines the package, for example if you 
want to change the source, I just want to go to different commits of the package I want to build, 
but I want to reuse the build file that is in nix package, how do I do that?

Silvan: Yeah, good question. I'm gonna share the screen here, we open like a `test.nix` file. 

```
vim test.nix  
```

So I guess you're asking so if you have like nixpkgs here:

```nix
let
  pkgs = import <nixpkgs> {};
```

And I guess let's add an overlay in here:

```nix
let
  pkgs = import <nixpkgs> {};
in pkgs.hello
```

And you have some overlays:

```nix
let
  pkgs = import <nixpkgs> {
    overlays = [
      ()
    ]
  };
in pkgs.hello
```

Like this, `self`, `super`, let's use `final` and `prev`, a bit more intuitive, all right:

```nix
let
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello =
      })
    ];
  };
in pkgs.hello
```

So now, generally you'd do, so you are asking about, we have like `hello = prev.hello.override`,
to do like, let's look at the `hello` derivation what that has:

```
> 'hello/default.nix' 
```
> Note: Currently, it's found under `hello/package.nix`

Here, so these are the arguments:

```nix
{
  callPackage,
  lib,
  stdenv,
  fetchurl,
  nixos,
  testers,
  versionCheckHook,
  hello,
}:
```

So these are the arguments that `.override` overrides but I guess you want to override the source here:

```nix
  src = fetchurl {
    url = "mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz";
    hash = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
  };
```

and so this would be `.overrideAttrs`. The naming is a bit weird and the functions don't work exactly
the same way but this is the general kind of mapping, so all the attributes are `.overrideAttrs`,
so if you go in here:

```
vim test.nix
```

Let's do like an override first, to do like, oh I forget what the arguments were:

```
vim pkgs/by-name/he/hello/package.nix
```

We have like, `fetchurl`, let's make `fetchurl` throw an error:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = prev.hello.override {
          fetchurl = throw "not fetchurl";
        };
      })
    ];
  };
in pkgs.hello
```

So that works, let's make sure we can evaluate this, I'm gonna run a, I guess `:!nix-build test.nix`:

```nix
nix-build test.nix
error: not fetchurl
(use '--show-trace' to show detailed location information)

shell returned 1
```

> Note: currently the error has more output:

```nix
nix-build test-v1-fetchurl-error.nix
error:
       … while calling the 'derivationStrict' builtin
         at <nix/derivation-internal.nix>:34:12:
           33|
           34|   strict = derivationStrict drvAttrs;
             |            ^
           35|

       … while evaluating derivation 'hello-2.12.1'
         whose name attribute is located at /nix/store/lifi3q1an6mgsksd52hizhhjfj1yf6sg-nixos/nixos/pkgs/stdenv/generic/make-derivation.nix:375:7

       … while evaluating attribute 'src' of derivation 'hello-2.12.1'
         at /nix/store/lifi3q1an6mgsksd52hizhhjfj1yf6sg-nixos/nixos/pkgs/by-name/he/hello/package.nix:16:3:
           15|
           16|   src = fetchurl {
             |   ^
           17|     url = "mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz";

       (stack trace truncated; use '--show-trace' to show the full, detailed trace)

       error: not fetchurl
```

OK, that works. It's not fetchurl. Oh, but now I guess we could try this, we could add the overrideAttrs:

```nix
hello = (prev.hello.override {
  fetchurl = throw "not fetchurl";
}).
```

and we are gonna override the source to not use fetchurl so we get a working something like, 
we can do this with `overrideAttrs`:

```nix
hello = (prev.hello.override {
  fetchurl = throw "not fetchurl";
}).overrideAttrs
```

One notable difference, which I think it's still the case is that `overrideAttrs` takes a function,
(`overrideAttrs (`), not.. it always takes a function, `override` can take an attribute set directly 
here: (`{fetchurl = throw "not fetchurl";}`) or it can take a function that return an attribute set, 
`overrideAttrs` is a bit different in that it always needs a function. So here `.overrideAttrs (`, 
the argument what people generally call that I think it's `drv:` or `oldAttrs: {}`, something like that. 
The argument here (`oldAttrs: `) represents the old attributes that were passed to the derivation, 
and so here we also have access to like the source, we can say `src = oldAttrs.src;`. Doesn't change
anything but we have access to that. Sometimes it's useful when you want to do like `nativeBuildInputs`
so you want to add some build tooling, some tooling onto your (used? 4.39) build time, if you just
do something like this:

```nix
nativeBuildInputs = [ ];
```

Let's do `final.` let's say `jq`:

```nix
nativeBuildInputs = [
  final.jq
];
```

Anything really. So this would clear `nativeBuildInputs`, it would remove all the  old entries,
so to get around this you generally do `oldAttrs.nativeBuildInputs` plus (`++`), list append
all the old entries and the new one, though sometimes I think that can happen,
`nativeBuildInputs`doesn't exist as an attribute so it wasn't even defined so then you need
a an additional `or` here:

```nix
nativeBuildInputs = oldAttrs.nativeBuildInputs or [] ++ [
  final.jq
];
```

Because to, just to have a default in case it doesn't exist, that is sometimes a bit..

Yuriy Taraday: Isn't it defined by the derivation?

Silvan: It might be, I'm not entirely sure, I guess let's actually test this, it might
be good thing here, let's test it just like that:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          fetchurl = throw "not fetchurl";
        }).overrideAttrs (oldAttrs: {
          src = oldAttrs.src;
          
          nativeBuildInputs = oldAttrs.nativeBuildInputs ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

```nix
nix-build test.nix
error: attribute 'nativeBuildInputs' missing
# ...
```
Ah yes, it's, `nativeBuildInputs` is missing.

Yuriy: Okay

Silvan: Now if we add this, (`or []`) it should work:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          fetchurl = throw "not fetchurl";
        }).overrideAttrs (oldAttrs: {
          src = oldAttrs.src;
          
          nativeBuildInputs = oldAttrs.nativeBuildInputs ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

We still get the not fetchurl error. This is sometimes a bit confusing here though
because `or` does have a higher precedence than kind of this kind of thing:
(`[] ++ [ final.jq ];`), so this does this:

> Note: Adds parenthesis around `oldAttrs...[]`

```nix
nativeBuildInputs = (oldAttrs.nativeBuildInputs or []) ++ [
  final.jq
];
```

But it might also look that it could do this:

> Note: Adds parenthesis around `([] ++ [ final.jq ]);`

```nix
nativeBuildInputs = oldAttrs.nativeBuildInputs or ([] ++ [
  final.jq
]);
```

But yeah, this is what happens underneath and so if you want you could add these parenthesis
on your own just to make it clear what the order of operations is here:

```nix
nativeBuildInputs = (oldAttrs.nativeBuildInputs or []) ++ [
  final.jq
];
```

So overriding source here, (`src`), so here we do need to override the entire source
attribute, let's look at the hello derivation again to see what the source there was:

```
nvim pkgs/by-name/he/hello/package.nix
```

So it was fetched from this kind of thing:

```nix
  src = fetchurl {
    url = "mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz";
    hash = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
  };
```

All right, let's go `test.nix` and pop in that, put it in here, we need to update the
references here, and say `final.fetchurl`:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          fetchurl = throw "not fetchurl";
        }).overrideAttrs (oldAttrs: {
          
          src = final.fetchurl {
            url = "mirror://gnu/hello/hello-${finalattrs.version}.tar.gz";
            hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
          };

          nativebuildinputs = oldAttrs.nativebuildinputs or [] ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

Here we also have something kind of new in nixpkgs (`finalAttrs.version`), where, well
let's go back to the hello example here:

```nix
stdenv.mkDerivation (finalAttrs: {
  pname = "hello";
  version = "2.12.1";
})
```

This is kind of written in a new style here where make derivation takes a function returning
an attribute. Generally it was always like this:

```nix
stdenv.mkDerivation {
  pname = ...
# ...
```

but this then pushed people to using the `rec` here:

```nix
stdenv.mkDerivation rec {
```

because in this case you want to use the version and how do you not duplicate the
version thing here (`{version}`), you do that by, you could do that with a `rec` here, 
this makes it a recursive attribute set, where all the values are kind of brought into 
scope, but this is a very local thing, like just local to this definition and it's not 
propagated outside of that so in the end the values are still kind of duplicated at the 
nix structure where this string doesn't know `url = ...{version}..`, if you change the 
version here (`version = "2.12.1";`), it's gonna keep the old version here,
(`url = "mirror://gnu/hello..{version}.tar.gz";`) so that was kind of a complaint with
`mkDerivation` so recently it was added that you can use a function here:

```nix
stdenv.mkDerivation (finalAttrs: {
```

and then the function argument here (`finalAttrs`) refers to the actual final attributes,
even if they have been changed by overrides and such, and so here, this is why you can
refer to `{finalAttrs.version}` here. It is a very new thing here, I don't think a lot
convention has been established around whether they should be used for all derivations
but if you want to you can use that.

Soham Chowdhury: What is the advantage of this over the `rec`, isn't it equivalent in
the end?

Silvan: It looks like if you just have a derivation like this, it does make a difference
if you have a `.overrideAttrs` because, we can test this out here:

```
nvim pkgs/by-name/he/hello/package.nix
```

So the hello derivation currently uses the function, so if we do:

```
vim test.nix
```

Let's say we override..

Yuriy Taraday: Set version to two twelve

Silvan: Yeah, we could do this here, (`version = "2.12";`), well in this case let
me undo this and let me undo this as well:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          #fetchurl = throw "not fetchurl";
        }).overrideAttrs (oldAttrs: {
          version = "2.12";
          # src = fetchurl {
          #url = "mirror://gnu/hello/hello-${finalattrs.version}.tar.gz";
          #hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
          #};

          nativebuildinputs = oldattrs.nativebuildinputs or [] ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

So we only override the version here, actually I don't think this does anything in
this case because the source has a fixed output hash so it doesn't really do much
I think, we could try:

```nix
nix-build test-v4-override.nix
these 2 derivations will be built:
  /nix/store/sihfj1b79w2xazpa826vqqwcdgbrkg1p-hello-2.12.tar.gz.drv
  /nix/store/3m8s848r1wj6d2fq7if2ciwfd6jprfdn-hello-2.12.drv
this path will be fetched (0.00 MiB download, 0.00 MiB unpacked):
  /nix/store/096i6ysqh596z1srsh758z3swz00kmlr-version-check-hook
copying path '/nix/store/096i6ysqh596z1srsh758z3swz00kmlr-version-check-hook' from 'https://cache.nixos.org'...
building '/nix/store/sihfj1b79w2xazpa826vqqwcdgbrkg1p-hello-2.12.tar.gz.drv'...

trying https://ftpmirror.gnu.org/hello/hello-2.12.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0
100  993k  100  993k    0     0   147k      0  0:00:06  0:00:06 --:--:--  209k
error: hash mismatch in fixed-output derivation '/nix/store/sihfj1b79w2xazpa826vqqwcdgbrkg1p-hello-2.12.tar.gz.drv':
         specified: sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=
            got:    sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=
error: 1 dependencies of derivation '/nix/store/3m8s848r1wj6d2fq7if2ciwfd6jprfdn-hello-2.12.drv' failed to build
```

Yuriy Taraday: .. I know that src dot sha256 will not work but do you think there is some way to
overwrite src here, just the hash here?

Silvan: I.. I think we can do that actually with `url = oldAttrs`, and maybe we should call this
`finalAttrs` because that's also what the hello derivation calls it, `url = finalAttrs.src.url;`
I do believe the fetchurl function exports the url as like an attribute

Yuriy Taraday: Yeah

Silvan: It might also be `urls`, let's see whether this works:

Yuriy Taraday: I think it's both.

```nix
# ...
 .overrideAttrs (finalAttrs: {
  version = "2.12";
  src = final.fetchurl {
    url = finalAttrs.src.url;
    
```

Or we could also, let's just do this for now, overide version and then check the value in here:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          #fetchurl = throw "not fetchurl";
        }).overrideAttrs (finalAttrs: {
          version = "2.12";
          # src = final.fetchurl {
          #url = finalAttrs.src.url;
          #hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
          #};

          nativebuildinputs = (oldAttrs.nativebuildinputs or []) ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

Let's go into nix repl. Let's do like a:

```nix
nix-repl> hello = import ./test-v5.nix

nix-repl> hello

error:
       … while calling the 'import' builtin
         at «string»:1:2:
            1|  import ./test-v5.nix
             |  ^

       error: undefined variable 'oldAttrs'
       at /home/stablejoy/code/nix-hour-transcripts/episodes/2/test-v5.nix:14:32:
           13|
           14|           nativebuildinputs = (oldAttrs.nativebuildinputs or []) ++ [
             |                                ^
           15|             final.jq
```

So this should be the hello derivation output. We messed up the variable name here so, `oldAttrs`
`finalAttrs` now:

```nix
> nix repl
nix-repl> hello = import ./test-v5.nix

nix-repl> hello
«derivation /nix/store/3m8s848r1wj6d2fq7if2ciwfd6jprfdn-hello-2.12.drv»
```

Now we can access the source from that derivation, just another derivation:

```nix
nix-repl> hello.src
«derivation /nix/store/sihfj1b79w2xazpa826vqqwcdgbrkg1p-hello-2.12.tar.gz.drv»
```

Now we can look look at all the attributes in that source:

> Note: add dot, `.`, after `src`, in `hello.src.` press tab after `.`

```nix
nix-repl> hello.src.
hello.src.SSL_CERT_FILE                hello.src.doInstallCheck               hello.src.overrideAttrs
hello.src.__ignoreNulls                hello.src.downloadToTemp               hello.src.passthru
hello.src.__structuredAttrs            hello.src.drvAttrs                     hello.src.patches
hello.src.all                          hello.src.drvPath                      hello.src.postFetch
hello.src.args                         hello.src.executable                   hello.src.postHook
hello.src.buildInputs                  hello.src.impureEnvVars                hello.src.preferHashedMirrors
hello.src.builder                      hello.src.inputDerivation              hello.src.preferLocalBuild
hello.src.cmakeFlags                   hello.src.mesonFlags                   hello.src.propagatedBuildInputs
hello.src.configureFlags               hello.src.meta                         hello.src.propagatedNativeBuildInputs
hello.src.curlOpts                     hello.src.mirrorsFile                  hello.src.showURLs
hello.src.curlOptsList                 hello.src.name                         hello.src.stdenv
hello.src.depsBuildBuild               hello.src.nativeBuildInputs            hello.src.strictDeps
hello.src.depsBuildBuildPropagated     hello.src.nixpkgsVersion               hello.src.system
hello.src.depsBuildTarget              hello.src.out                          hello.src.type
hello.src.depsBuildTargetPropagated    hello.src.outPath                      hello.src.url
hello.src.depsHostHost                 hello.src.outputHash                   hello.src.urls
hello.src.depsHostHostPropagated       hello.src.outputHashAlgo               hello.src.userHook
hello.src.depsTargetTarget             hello.src.outputHashMode
hello.src.depsTargetTargetPropagated   hello.src.outputName
hello.src.doCheck                      hello.src.outputs
nix-repl> hello.src.
```

And is there url? There is a url:

```nix
nix-repl> hello.src.url
"mirror://gnu/hello/hello-2.12.tar.gz"
```

Okay that's cool. And so in this case we can see that the url was updated to 2.12. What was the old
version? We can also do this:

```nix
nix-repl> hello.overrideAttrs (finalAttrs: { version = "3"; })
«derivation /nix/store/mg990h0475l2gjqchs5sb0ggm8gjki27-hello-3.drv»
```

Just do this again. There's a new derivation, let's do hello three:

```nix
nix-repl> hello_3 = hello.overideAttrs (finalAttrs: { version = "3"; })
```

Now:

```nix
nix-repl> hello_3.src.url
"mirror://gnu/hello/hello-3.tar.gz"
```

That now has the url updated. This wouldn't work with `rec` way of doing nix things, it would
always keep the old one. And this might not be super useful for url here because you still need to
update the url in the end though I guess we could do this kind of pattern here if we want to reuse
the old url. We do need to update the hash here though. Otherwise it's just gonna reuse the
prefetched thing.

Yuriy Taraday: Isn't fetchurl also, does it produce derivation, should it also have a right uppers? 
(13:12) something.

Silvan: Ah, yes, let's see. Let's do `test.nix` does that work:

```nix
nix repl test.nix
warning: future versions of Nix will require using `--file` to load a file
#..
```

> Note: currently one has to pass `--file` otherwise:

```nix
# with `--file`
❯ nix repl --file test-v5.nix
Nix 2.24.11
Type :? for help.
Loading installable ''...
Added 47 variables.
nix-repl>
```

```nix
# without `--file`
❯ nix repl test-v5.nix
Nix 2.24.11ype :? for help.
error: path '/home/stablejoy/code/nix-hour-transcripts/episodes/2/test-v5.nix' is not a flake (because it's not a directory)
```

Ah that's the, let's do this:

```nix
❯ nix repl
Nix 2.24.11
Type :? for help.
nix-repl> hello = import ./test-v5.nix
```

Okay, we can look at source:

```nix
nix-repl> hello.src
«derivation /nix/store/sihfj1b79w2xazpa826vqqwcdgbrkg1p-hello-2.12.tar.gz.drv»
```

That's the source derivation. Now does this have `overrideAttrs`? It does:

```nix
nix-repl> hello.src.overrideAttrs
«lambda @ /nix/store/lifi3q1an6mgsksd52hizhhjfj1yf6sg-nixos/nixos/pkgs/stdenv/generic/make-derivation.nix:101:8»
```

Yuriy Taraday: So we could just add the new sha in `overrideAttrs` here, right?

Silvan: Oh yeah, that might work, let's, I do think there is, I'm not sure if it's `overrideAttrs`, this is
might not work:

```nix
nix-repl> lib.functionAttrs hello.src.overrideAttrs
error: undefined variable 'lib'
       at «string»:1:1:
            1| lib.functionAttrs hello.src.overrideAttrs
             | ^
```

Let's import `lib`:

```nix
nix-repl> lib = import <nixpkgs/lib>

nix-repl> lib.functionAttrs hello.src.overrideAttrs
error: attribute 'functionAttrs' missing
       at «string»:1:1:
            1| lib.functionAttrs hello.src.overrideAttrs
             | ^
```

```nix
nix-repl> lib.functionArgs hello.src.overrideAttrs  
{ }
```

Ah, that doesn't work. See, I would have liked to see what kind of things we can
override but I don't think that's supported. We can look at the implementation of
`fetchurl` though to see things it does.

Yuriy Taraday: We could try.

Silvan: Try the sha?

Yuriy: Yeah, just override the sha with some..

```nix
> fetchurl/default.nix

# ...

  # SRI hash.
  hash ? "",

  # Legacy ways of specifying the hash.
  outputHash ? "",
  outputHashAlgo ? "",
  sha1 ? "",
  sha256 ? "",
  sha512 ? "",

  recursiveHash ? false,
# ...
```

Silvan: Yeah it does have this here, well it might just work, let's try it. If
it does work we should get an error because we this source here shouldn't really
exist like `something-that-doesn't-exist`:

```nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          #fetchurl = throw "not fetchurl";
        }).overrideAttrs (finalAttrs: {
          version = "something-that-doesn't-exist";
          src = final.fetchurl {
            url = finalAttrs.src.url;
            hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
          };

          nativebuildinputs = (finalAttrs.nativebuildinputs or []) ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

All right, let's try this, let me comment this out, because this would also be a
way of doing it:

```nix
#src = final.fetchurl {
#url = finalAttrs.src.url;
#hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
#};
```

So let's look at `finalAttrs`:


```nix
#src = final.fetchurl {
#url = finalAttrs.src.url;
#hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
#};
src = finalAttrs.src.overrideAttrs (finalAttrs': {

});
```

I'm used to calling it old, now this is a bit confusing because we now have two
`finalAttrs`, let me prime one of those, so we are gonna call this `sha256 =` and
here I'm gonna ad this:

```nix
src = finalAttrs.src.overrideAttrs (finalAttrs': {
  sha256 = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
});
```

Yuriy: Let's change it to something random so that it doesn't clash.

Silvan: Yeah, let me do this:

```nix
src = finalAttrs.src.overrideAttrs (finalAttrs': {
  sha256 = "0000000000000000000000000000000000000000000000000000";
});
```

By the way, this is in vim, you can press 52 `i` zero then it inserts string of
that length with just zeros.

> Note: after zero press ESC to actually generate the string of numbers

Alexander Sosedkin: I think an empty string is also all zeros or even something..

Silvan: Oh yeah, yeah

Alexander Sosedkin: So, not that useful (chuckles)

Silvan: Yeah, good point. This didn't exist until recently I believe, nowadays you
don't need to do this anymore, thanks. So let's try this out again:

```nix
> nix-build test6.nix

building '/nix/store/dxgq953j7v1slncr3r54949jhcwsff0r-hello-something-that-doesn-t-exist.tar.gz.drv'...

trying https://ftpmirror.gnu.org/hello/hello-something-that-doesn't-exist.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0
  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0
curl: (22) The requested URL returned error: 404
```

Yeah, we can see that it tries to fetch it here..

Yuriy: Let's try for example, ...does it match what we have now but it exists.

Silvan: `2.12` is the current version.

Yuriy: `2.12.1` is current version, `2.12` is previous one so..

Silvan: Ah, I see

Yuriy: Why did it fail?

Silvan: It didn't fail

```nix
> ne -A hello.version
"2.12.1"
```

Yuriy: Maybe because of empty sha it didn't check it or something.

Alexander Sosedkin: No, it because it wasn't (operating?) I believe (17.01)

Silvan: Alexander you asked a question?

Alexander Sosedkin: I thought that is an indicator that the override didn't work,
the idea of overrideAttrs

Silvan: Yeah..

Alexander Sosedkin: We can try with a lot of zeros to double check.

Silvan: Yeah, that's a good point. I'll do this again to 12: `version = "2.12"`,
All right let me try this:

```nix
❯ nix-build test6.nix
these 2 derivations will be built:
  /nix/store/nbsibiddcvm33a6lzb7rlqci1z3051vv-hello-2.12.tar.gz.drv
  /nix/store/zk3318ngmmx1p6fg8yh4vfvxwjwkwibp-hello-2.12.drv
building '/nix/store/nbsibiddcvm33a6lzb7rlqci1z3051vv-hello-2.12.tar.gz.drv'...

trying https://ftpmirror.gnu.org/hello/hello-2.12.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100  993k  100  993k    0     0   345k      0  0:00:02  0:00:02 --:--:--  640k
error: hash mismatch in fixed-output derivation '/nix/store/nbsibiddcvm33a6lzb7rlqci1z3051vv-hello-2.12.tar.gz.drv':
         specified: sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=
            got:    sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=
error: 1 dependencies of derivation '/nix/store/zk3318ngmmx1p6fg8yh4vfvxwjwkwibp-hello-2.12.drv' failed to build
```

Soham Chowdhury: What is `ne`?

Silvan: Oh yeah, `> alias ne`, that's a local alias I have for just `nix-instantiate --eval`,
so `alias nb` for `nix-build` and `alias ns` for `nix-shell`. I'm using them all
the time so I want them to be short. I'm not exactly why this doesn't work right
now.

Yuriy: Maybe let's check in repl whether or not

Silvan: Yeah

```nix
nix repl

nix-repl> hello = import ./test6.nix
```

Soham Chowdhury: I'm a little surprised why the hello package has a version 2.12,
it feels like, what was the breaking change.

Silvan: So we can look at the url here:

```nix
nix-repl> hello = import ./test6.nix

nix-repl> hello.src
«derivation /nix/store/nbsibiddcvm33a6lzb7rlqci1z3051vv-hello-2.12.tar.gz.drv»

nix-repl> hello.src.url
"mirror://gnu/hello/hello-2.12.tar.gz"

nix-repl> hello.src.urls
[ "mirror://gnu/hello/hello-2.12.tar.gz" ]
```

Could be urls, no that's for when you have multiple, what about sha256?

```nix
nix-repl> hello.src.sha256
"0000000000000000000000000000000000000000000000000000"
```

Can we access that, we can access that. That's all zeros. Can we build this? What
if we build the source derivation?

```nix
nix-repl> :b hello.src
error: hash mismatch in fixed-output derivation '/nix/store/nbsibiddcvm33a6lzb7rlqci1z3051vv-hello-2.12.tar.gz.drv':
         specified: sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=
            got:    sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=
[0 built (1 failed), 0.0 MiB DL]
```
> Note: I seem to get a different ouput for now than what Silvan gets bellow.

We get this tarball. This sounds wrong:

```nix
nix-repl> :b hello.src

This derivation produced the following outputs:
  out -> /nix/store/...hello-2.12.tar.gz
```

Oh I know the problem. I don't think this is valid:

```nix
src = finalAttrs.src.overrideAttrs (finalAttrs': {
  sha256 = "0000000000000000000000000000000000000000000000000000";
});
```

Because we are overriding the attributes of the final derivation, we aren't
overriding the attributes of the function call for fetchurl. And so we can look
at the, we can look at this here:

```nix
❯ nix repl
Nix 2.24.11
Type :? for help.
nix-repl> hello = import ./test6.nix

nix-repl> hello.src
«derivation /nix/store/nbsibiddcvm33a6lzb7rlqci1z3051vv-hello-2.12.tar.gz.drv»
```

Again, I already talked about this at the NixCon. Yuri also knows this well, where
the nix repl doesn't show the actual derivation attributes by default.

```nix
nix-repl> hello.src // { type = ""; }
```

Because derivations have a derivation type in here:

```nix
nix-repl> hello.src // { type = "derivation"; }
```

But if we override this to something like an empty string or anything other than
derivation we can see all the attributes:

```nix
nix-repl> hello.src // { type = ""; }
{
  SSL_CERT_FILE = "/no-cert-file.crt";
  __ignoreNulls = true;
  __structuredAttrs = false;
  all = [ ... ];
  args = [ ... ];
  buildInputs = [ ... ];
  builder = "/nix/store/5mh7kaj2fyv8mk4sfq1brwxgc02884wi-bash-5.2p37/bin/bash";
  cmakeFlags = [ ... ];
  configureFlags = [ ... ];
  # ...
```

And these are the actual attributes that `.overrideAttrs` overrides, these are
what get's passed to the derivation builder underneath, and so in here we can
override the sha256 but that's then just an environment variable. If we actually
look at the implementation `fetchurl/default.nix`, `sha256` argument is taken
here somewhere and so it gets turned into a `hash_` and the hash gets turned into
`outputHash` and this is then the final attribute on the derivation. So we shouldn't
override the sha256 but this `outputHash` property but that's a bit weird and like
an implementation detail almost, so I wouldn't recommend this.

Yuriy: Can we override then instead of overrideAttrs?

Silvan: Override? Override on.. I don't think so

Yuriy: Override is produced by callPackage and fetchurl is a function..

Silvan: Yeah, but this would if we use override on fetchurl, we'd override these
arguments up here:

```nix
{ lib, buildPackages ? { inherit stdenvNoCC; }, stdenvNoCC
  , curl # ... }:
```

These are kind of the dependencies of fetchurl itself.

Yuriy: Not really I think, because..

Silvan: Oh you mean, I see, yeah, let's try it:

```nix
# ...
src = finalAttrs.src.override (finalAttrs': {
  sha256 = "0000000000000000000000000000000000000000000000000000";
});
```

Let's try building that:

```nix
❯ nix-build test7.nix
error:
       … while calling the 'derivationStrict' builtin
         at <nix/derivation-internal.nix>:34:12:
           33|
           34|   strict = derivationStrict drvAttrs;
             |            ^
           35|

       … while evaluating derivation 'hello-2.12'
         whose name attribute is located at /nix/store/cxzvgh0g8fknrv9s5r4icihwcyi0yaac-nixos/nixos/pkgs/stdenv/generic/make-derivation.nix:375:7

       … while evaluating attribute 'src' of derivation 'hello-2.12'
         at /home/stablejoy/code/nix-hour-transcripts/episodes/2/test7.nix:14:13:
           13|
           14|             src = finalAttrs.src.override (finalAttrs': {
             |             ^
           15|               sha256 = "0000000000000000000000000000000000000000000000000000";

       (stack trace truncated; use '--show-trace' to show the full, detailed trace)

       error: attribute 'override' missing
       at /home/stablejoy/code/nix-hour-transcripts/episodes/2/test7.nix:14:19:
           13|
           14|             src = finalAttrs.src.override (finalAttrs': {
             |                   ^
           15|               sha256 = "0000000000000000000000000000000000000000000000000000";
```

Override missing.

Yuriy: I think we should have this. I think it would be quite useful. When you just
want to change a version this structure would have been much nicer than having
to remember to like..

Silvan: That's something to look at definetly, there's lots of improvements
possible there. I do want to try this as well:

```nix
src = finalAttrs.src.overrideAttrs (finalAttrs: {
  outputHash = "0000000000000000000000000000000000000000000000000000";
});
```

Not recommended, but just to see if it works. Let's try building that:

```nix
> nix-build test8.nix
error: hash '0000000000000000000000000000000000000000000000000000' does not
include a type, nor is the type otherwise known from context
```

So with overrideAttrs you have to do this (`outputHash = "00..";`) but that's a
bit annoying so I think for now this would be the best to go back here.. or let's
also quickly try out the empty hash here: 

```nix
#..
outputHash = "";
#..
```

```nix
> nix-build test9.nix
 error: empty hash requires explicit hash algorithm
```

So yeah, that also works, we can see that, well it's gone now, well we saw that
the nix inferred the kind of all null hash.

Alexander Sosedkin: Do I understand correctly that like in the beginning you have
said that this new style and old style of writing a derivation for hello when the
derived attribute is like derived on one level or another level and now we have the
same problem with fetchurl and we need a new style fetchurl. Is this the correct
analogy?

Silvan: Yes, it's, fetchurl is a bit separate because it's a function, not a
derivation, and these functions have like, they're called, so, yes, so that kind
of new style of finalAttrs here, well let's go to hello..

Alexander Sosedkin: When you override the version on old style hello it doesn't
propagate to source, but if you override and `src.url` on an old style fetchurl,
it doesn't.. if you override sha256 it doesn't propagate the hash. The propagation
should be like smarter in overrideAttrs with regards to..

Silvan: Yeah, it's not exactly the same problem because in here the problem was
that we used the `rec` whereas in the fetchurl the problem is the output here,
(`outputHash = " 00..";`), the attribute here doesn't correspond to the one we
want to override and also the override is also not available, but it's a bit
similar, it kind of looks the same. That's something that we, as part of the
nix architecture team, that's something that needs to be fixed, it's on the radar,
this is pretty bad, for now I guess this is the recommendation I'd make.

Yuriy: By the way, if the original derivation had this hash, like on the level
of the derivation itself, then we could have just overriden it via overrideAttrs
of that derivation itself right? So like..

Silvan: You mean if we, if the implementation detail would have used the sha256
attribute.

Yuriy: No, I mean if the hello, if the derivation itself have version, then hash,
and then src derived from version and hash. Then we could have just overriden it
but it's not nice repeating stuff.

Silvan: Yeah, yeah, let's see if we had this here, this would work, yeah:

> Note: copies sha256 from `src` after `version`

```nix
# ~/nixpkgs/pkgs/by-name/he/hello/package.nix
stdenv.mkDerivation (finalAttrs: {
  pname = "hello";
  version = "2.12.1";
  sha256 = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
  
  src = fetchurl {
    url = "mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz";
    hash = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
  };
```

I guess let's try it out, maybe someone would be interested in doing this for
like, I'm not sure if it would be accepted in nixpkgs, but at least for now like
this, this looks pretty good actually:

```nix
# ~/nixpkgs/pkgs/by-name/he/hello/package.nix
stdenv.mkDerivation (finalAttrs: {
  pname = "hello";
  version = "2.12.1";
  sha256 = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
  
  src = fetchurl {
    url = "mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz";
    hash = finalAttrs.sha256;
  };
```

So not possible for most derivations right now but let's see here, let's try to
build this:

```nix
# test.10.nix
let 
  pkgs = import <nixpkgs> {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          #fetchurl = throw "not fetchurl";
        }).overrideAttrs (finalAttrs: {
            version = "2.12";
            sha256 = "";

            #src = final.fetchurl {
            #url = finalAttrs.src.url;
            #hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
            #};

            src = finalAttrs.src.overrideAttrs (finalAttrs': {
              outputHash = "";
            });

          nativebuildinputs = (finalAttrs.nativebuildinputs or []) ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

Yuriy: ..nixpkgs, import.

Silvan: What I should do?

Yuriy: Import nixpkgs from the outside, from what you changed.

Silvan: Oh, yeah, good point. Let's import the local nixpkgs, (`pkgs = import ./.`):

> Note: I used the absolute path to my nixpkgs source directory, which may mean
Silvan was building test.nix in the nixpkgs directory itself?

```nix
let 
  pkgs = import ./. {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          #fetchurl = throw "not fetchurl";
        }).overrideAttrs (finalAttrs: {
            version = "2.12";
            sha256 = "";

            #src = final.fetchurl {
            #url = finalAttrs.src.url;
            #hash = "sha256-jzkukv2sv28wsm18tcqnxoczmlxdyh2idh9rlibh2ya=";
            #};

            # Not working
            # src = finalAttrs.src.overrideAttrs (finalAttrs': {
            #  outputHash = "";
            #});

          nativebuildinputs = (finalAttrs.nativebuildinputs or []) ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

Okay, that worked.

Alexander Sosedkin: I would prefer superpower to overrideAttrs which recalculates
and derive attributes to that pattern, but yeah, that's one way to do it.

Silvan: Yeah, mhm, yeah, so I guess for now this is probably the best approach,
general approach:

```nix
let 
  pkgs = import /home/stablejoy/src/nixpkgs {
    overlays = [
      (final: prev: {
        hello = (prev.hello.override {
          #fetchurl = throw "not fetchurl";
        }).overrideAttrs (finalAttrs: {
            version = "2.12";

            # For now this is probably the best general approach
            src = final.fetchurl {
            url = finalAttrs.src.url;
            hash = "";
            };

            # Not working
            #src = finalAttrs.src.overrideAttrs (finalAttrs': {
            #outputHash = "";
            #});

          nativebuildinputs = (finalAttrs.nativebuildinputs or []) ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

```nix
❯ nix-build test11.nix
warning: found empty hash, assuming 'sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA='
these 2 derivations will be built:
  /nix/store/n79jkk1gqq1mibzbgnapwxcd45qnl1dx-hello-2.12.tar.gz.drv
  /nix/store/1wk7mxi2qcpxv84lqqajbq98rpbc2jpr-hello-2.12.drv
building '/nix/store/n79jkk1gqq1mibzbgnapwxcd45qnl1dx-hello-2.12.tar.gz.drv'...

trying https://ftpmirror.gnu.org/hello/hello-2.12.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:--  0:00:06 --:--:--     0
100  993k  100  993k    0     0   114k      0  0:00:08  0:00:08 --:--:--  540k
error: hash mismatch in fixed-output derivation '/nix/store/n79jkk1gqq1mibzbgnapwxcd45qnl1dx-hello-2.12.tar.gz.drv':
         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
            got:    sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=
error: 1 dependencies of derivation '/nix/store/1wk7mxi2qcpxv84lqqajbq98rpbc2jpr-hello-2.12.drv' failed to build
❯ nvim test11.nix
```

So I guess now, let's backtrack a little bit, let's go, do the fetchurl throw here,
so I'm gonna comment this for now just to see that the error is still there:

```nix
# ..
fetchurl = throw "not fetchurl";
# ..
# For now..
#
#
#
#
```
```nix
❯ nix-build test12.nix
error:
       … while calling the 'derivationStrict' builtin
         at <nix/derivation-internal.nix>:34:12:
           33|
           34|   strict = derivationStrict drvAttrs;
             |            ^
           35|

       … while evaluating derivation 'hello-2.12'
         whose name attribute is located at /home/stablejoy/src/nixpkgs/pkgs/stdenv/generic/make-derivation.nix:375:7

       … while evaluating attribute 'src' of derivation 'hello-2.12'
         at /home/stablejoy/src/nixpkgs/pkgs/by-name/he/hello/package.nix:16:3:
           15|
           16|   src = fetchurl {
             |   ^
           17|     url = "mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz";

       (stack trace truncated; use '--show-trace' to show the full, detailed trace)

       error: not fetchurl
```

It is still here. Now if we enable this we should not get the.. we do get the error
still:

```nix
❯ nix-build test13.nix
# ...
  error: not fetchurl
```

Oh, we are accessing `finalAttrs.src` here. Yes, so I guess this doesn't work
because this here (`finalAttrs.src`) is a fetchurl call which now throws an error
so this is a bad example (`# fetchurl = throw "not fetchurl";`)
but I think we've proven that overriding the source works with the overrideAttrs
here. All right do we have any questions about this or related to this.

Yuriy: Who asked this, was it Quentin?

Quentin Aristote: Yeah..

Yuriy: Great.

Silvan: Awesome. Let's see, we have overlays, we had source fetchers. I guess we
can make a transition to SRI hashes which are kind new but maybe most people know
about them where let's say, right we want to use `2.12`, let's clean this up a
little bit here, let's get rid of this, we have the recording, it's fine

Yuriy: You can always.. from the recording right?

Silvan: Yeah, that's a good point, maybe we should publish the code somewhere
for this, but let's try:

```nix
# test14.nix

let 
  pkgs = import /home/stablejoy/src/nixpkgs {
    overlays = [
      (final: prev: {
        hello = prev.hello.overrideAttrs (finalAttrs: {
            version = "2.12";

            # For now this is probably the best general approach
            src = final.fetchurl {
            url = finalAttrs.src.url;
            hash = "";
            };

          nativebuildinputs = (finalAttrs.nativebuildinputs or []) ++ [
            final.jq
          ];
        });
      })
    ];
  };
in pkgs.hello
```

```nix
> nix-build test14.nix
# ...
  specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
            got:    sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=
# ...
```

We can already see here nix uses SRI hashes, these are in that form, they document
the hash algorithm they use in the beginning and they use a base64 encoding which
notably uses uppercase, lowercase letters and has like two special symbols and then
equals at the end, and so in this case, let's actually copy this hash here, let's copy
this and and copy it in here, and that should work, we should be able to build:

```nix
# > nix-build test15.nix
# ...
Device: 259,2   Inode: 41716741    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: ( 1000/  nixbld)   Gid: (  100/  nixbld)
Access: 2025-01-17 07:40:58.122967135 +0000
Modify: 2025-01-17 07:40:58.061974259 +0000
Change: 2025-01-17 07:40:58.102969471 +0000
 Birth: 2025-01-17 07:40:58.017979398 +0000
/nix/store/hwsfbqim46vgsf2rhy14z0dahdippvhf-hello-2.12
```

It seems to work fine, but this is kind of redundant here (`sha256 = ".."`) so
I think all of the fetchers also have hash attribute which can be more generic
hash and I think this should also work (`hash = "sha256..";`), yea. Yeah, so that's
also kind of cool, you can also use of course more, you can use `sha512` if you are
concerned about sha256. I think for now it's still safe to use 256

Yuriy: Although this is a hash, a NAR hash, right, of the result. But the result
is a tuple, it is the same. If the result of the fetch wasn't a tarball but like

Silvan: Yeah, I'm actually, it's actually `fetchurl` makes the hash of a single
file but yeah that's good, we can look at that, so let's go back into the repl,
let's checkout `hello`, `hello.src` again:

```nix
nix-repl> hello = import ./test15.nix

nix-repl> hello.src
«derivation /nix/store/sbjlhgbsj7vimg5pzspdsjc8x46cr999-hello-2.12.tar.gz.drv»
```

And so in this case we can look at output (`hello.src.output`) so these are
attributes on the derivation itself:

```nix
nix-repl> hello.src.output
hello.src.outputHash      hello.src.outputHashMode  hello.src.outputs
hello.src.outputHashAlgo  hello.src.outputName
```

These are passed to the derivation builtin, derivation nix function:

```nix
nix-repl> derivation
«lambda @ <nix/derivation-internal.nix>:30:1»
```

There's some `outputHash` attributes in here:

```nix
nix-repl> hello.src.outputHash
hello.src.outputHash      hello.src.outputHashAlgo  hello.src.outputHashMode
```

These are only there for fixed output derivations and so this is when the derivations
are, their path is derived from the hash specified here, so we have output hash here,
that's the hash we specified in the file:

```nix
nix-repl> hello.src.outputHash
"sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks="
```

We have:

```nix
nix-repl> hello.src.outputHashAlgo
null
```

That's, I guess `null`, I guess it's not needed anymore, that's, we can ignore
that, but there is also:

```nix
nix-repl> hello.src.outputHashMode
"flat"
```

There's two modes that nix hashes files with. There's the flat mode which works
on a single file, so what it does, let's try building it here:

```nix
nix-repl> :b hello.src

This derivation produced the following outputs:
  out -> /nix/store/8nqv6kshb3vs5q5bs2k600xpj5bkavkc-hello-2.12.tar.gz
```

So it fetches a derivation to verify whether nix can put it into store and to be
valid, it's going to take that file, the single file and it's gonna really just
run sha256 on it:

```
❯ sha256sum /nix/store/8nqv6kshb3vs5q5bs2k600xpj5bkavkc-hello-2.12.tar.gz
cf04af86dc085268c5f4470fbae49b18afbc221b78096aab842d934a76bad0ab  /nix/store/8nqv6kshb3vs5q5bs2k600xpj5bkavkc-hello-2.12.tar.gz
```

So we get the hash out of here, the hash from sha256sum is in hexadecimal so it
doesn't look the same. I think we can convert that to the SRI hash format with
`nix hash --help`, let's take a look here, here:

```nix
· 8;;./nix3-hash-to-sri.mdnix hash to-sri8;; - convert a hash to SRI representation (deprecated, use nix hash convert instead)
```

> Note: the output currently looks like this.

So we can get the type as well, all right, so let's do:

```nix
❯ nix hash to-sri --type sha256 cf04af86dc085268c5f4470fbae49b18afbc221b78096aab842d934a76bad0ab

warning: The old format conversion sub commands of `nix hash` were deprecated in favor of `nix hash convert`.
sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=
```

We're gonna give it this hex hash I copied. And we're gonna get this string, which
I believe, if I copy this one, is the same as in here, yes:

```nix
            # For now this is probably the best general approach
            src = final.fetchurl {
            url = finalAttrs.src.url;
            hash = "sha256-zwSvhtwIUmjF9EcPuuSbGK+8Iht4CWqrhC2TSna60Ks=";
            };
```

So really, nix really does the sha256 on the path that is being fetched here, it
doesn't do any unpacking notably. The other hash is recursive I believe. Oh yeah,
we can, nix hash, oh yeah we have a flage here for `--flat`:

```nix
❯ nix-hash --help
```

Yeah, so two modes are flat and I think recursive it's called in nix. If it's not
flat it's gonna compute the hash over the dump of path, which.. it's not really
super well documented here, is dump documented anywhere here, oh yeah okay, if
it's not flat it's gonna use `nix-store --dump` which just creates a NAR format,
and NAR stands for nix archive format or so and then it hashes this NAR contents
and so for some fetchers it just does that instead so let's say we're gonna do
`fetchFromGithub` instead, we're gonna say okay let's do `owner = tweag;`,
`repo = `, let's pick infinisil instead, `owner = infinisil;`, `repo = nixus`,
I don't really want to make ads here, `repo = system`, that's my system configuration,
that sounds good, let's pick some revision, pick master



